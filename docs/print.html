<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>FeGen</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="intro.html">Introduction</a></li><li class="chapter-item expanded "><a href="quickstart/intro.html"><strong aria-hidden="true">1.</strong> Quick Start Guide</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="quickstart/setup.html"><strong aria-hidden="true">1.1.</strong> Setup</a></li><li class="chapter-item expanded "><a href="quickstart/backend.html"><strong aria-hidden="true">1.2.</strong> Backend</a></li><li class="chapter-item expanded "><a href="quickstart/frontend.html"><strong aria-hidden="true">1.3.</strong> Frontend</a></li><li class="chapter-item expanded "><a href="quickstart/further_reading.html"><strong aria-hidden="true">1.4.</strong> Further Reading</a></li></ol></li><li class="chapter-item expanded "><a href="reference/intro.html"><strong aria-hidden="true">2.</strong> Reference Documentation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/plugin_configuration/intro.html"><strong aria-hidden="true">2.1.</strong> Plugin Configuration</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/plugin_configuration/gradle.html"><strong aria-hidden="true">2.1.1.</strong> Gradle</a></li><li class="chapter-item expanded "><a href="reference/plugin_configuration/maven.html"><strong aria-hidden="true">2.1.2.</strong> Maven</a></li><li class="chapter-item expanded "><a href="reference/plugin_configuration/configuration_options.html"><strong aria-hidden="true">2.1.3.</strong> Configuration Options</a></li></ol></li><li class="chapter-item expanded "><a href="reference/data_model/intro.html"><strong aria-hidden="true">2.2.</strong> Data Model</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/data_model/entities.html"><strong aria-hidden="true">2.2.1.</strong> Entities</a></li><li class="chapter-item expanded "><a href="reference/data_model/relationships.html"><strong aria-hidden="true">2.2.2.</strong> Relationships</a></li><li class="chapter-item expanded "><a href="reference/data_model/custom_endpoints.html"><strong aria-hidden="true">2.2.3.</strong> Custom Endpoints</a></li><li class="chapter-item expanded "><a href="reference/data_model/fegen_ignore.html"><strong aria-hidden="true">2.2.4.</strong> @FegenIgnore</a></li></ol></li><li class="chapter-item expanded "><a href="reference/retrieving/intro.html"><strong aria-hidden="true">2.3.</strong> Retrieving Data</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/retrieving/projections.html"><strong aria-hidden="true">2.3.1.</strong> Projections</a></li><li class="chapter-item expanded "><a href="reference/retrieving/paging_sorting.html"><strong aria-hidden="true">2.3.2.</strong> Paging and Sorting</a></li><li class="chapter-item expanded "><a href="reference/retrieving/repository_searches.html"><strong aria-hidden="true">2.3.3.</strong> Repository Searches</a></li><li class="chapter-item expanded "><a href="reference/retrieving/custom_searches.html"><strong aria-hidden="true">2.3.4.</strong> Custom Searches</a></li></ol></li><li class="chapter-item expanded "><a href="reference/targets/intro.html"><strong aria-hidden="true">2.4.</strong> Targets</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/targets/web.html"><strong aria-hidden="true">2.4.1.</strong> Web (Typescript)</a></li><li class="chapter-item expanded "><a href="reference/targets/android.html"><strong aria-hidden="true">2.4.2.</strong> Android (Kotlin)</a></li><li class="chapter-item expanded "><a href="reference/targets/inter_service.html"><strong aria-hidden="true">2.4.3.</strong> Spring Inter Service (Kotlin)</a></li></ol></li><li class="chapter-item expanded "><a href="reference/base_path.html"><strong aria-hidden="true">2.5.</strong> Base Path</a></li><li class="chapter-item expanded "><a href="reference/security.html"><strong aria-hidden="true">2.6.</strong> Security</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">FeGen</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>FeGen helps you write web and mobile apps with Spring Boot backends.
It does so by generating client code based on your Spring server, so you can access your Spring Data REST API in a type safe manner.
Typescript and Kotlin are supported as frontend languages, so you can use FeGen when creating a web app, a native Android app or another Spring application.</p>
<h2 id="why-fegen"><a class="header" href="#why-fegen">Why FeGen?</a></h2>
<p>What FeGen basically does is generating types and methods for a client to use the API of a spring application.
In that way, its goals are similar to projects like OpenAPI and GraphQL.
FeGen's disadvantage compared to those technologies is, that it only works for Spring Boot backends.</p>
<p>However, this is also a major advantage, since FeGen can leverage the APIs that Spring Data REST offers by default.
When using FeGen, you are able to simply define a data structure using JPA entities, create the corresponding repositories, and FeGen will give you methods and types to simply create, read, update and delete those entities.
For use cases that are not too complex, this greatly reduces the amount of boilerplate code you need to write.</p>
<p>You can also define repository and custom searches in FeGen that will provide you with only a subset of the available entities.
In more complicated cases, you can also use custom endpoints to have full control over what happens in the backend and what is returned by it.</p>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h2>
<p>If you are new to FeGen, please follow the <a href="./quickstart/intro.html">Quick Start Guide</a> to get an idea of how FeGen works and how you can use it.
Once you finished the <a href="./quickstart/intro.html">Quick Start Guide</a>, you can go more into detail and e.g. learn how to use FeGen to access your backend from Android or another Spring application, by referring to the <a href="./reference/intro.html">Reference Documentation</a>.</p>
<h1 id="quick-start-guide"><a class="header" href="#quick-start-guide">Quick Start Guide</a></h1>
<p>On the following pages you will learn how to create a simple web application using Spring, FeGen and Typescript.
It will allow you to create, view, edit and delete items from a todo list.
This guide is recommended even if you use case differs, e.g. because you want to use Kotlin in the backend or want to generate code for a Kotlin client like an Android app or another spring application.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>In order to follow this guide, you will need to have a basic understanding of Java, Spring Boot and Typescript.</p>
<p>You will also need to have Node.js installed to create the frontend.
Go to <a href="https://nodejs.org/">https://nodejs.org/</a> in order to download and install Node.js for your operating system, if you haven't already.</p>
<h1 id="setup"><a class="header" href="#setup">Setup</a></h1>
<p>In this step you will initialize your backend and frontend project and configure them to use FeGen.</p>
<p>The first thing you should do is create a directory for your project.</p>
<pre><code class="language-shell">mkdir todo-app
</code></pre>
<h2 id="creating-the-backend"><a class="header" href="#creating-the-backend">Creating the backend</a></h2>
<p>To create the web server for your application, you can use the spring initializr.
Go to <a href="https://start.spring.io/">https://start.spring.io/</a>.
Select the <code>Gradle Project</code> and <code>Java</code> radio buttons and change the artifact metadata to <code>backend</code> (The name will automaticaly change as well).</p>
<blockquote>
<p>FeGen also supports Maven and Kotlin, but they are not used in this guide in order to keep it simple.
If you want to know how to configure FeGen with Maven, refer to the <a href="quickstart/../reference/plugin_configuration/maven.html">Maven</a> page of the reference documentation.</p>
</blockquote>
<p>To use your Spring Boot application as a backend for your web application, you will need to add the following dependencies using the button in the top right:</p>
<ul>
<li><code>Spring Web</code>
<ul>
<li>to allow your website to communicate with the backend using REST</li>
</ul>
</li>
<li><code>H2 Database</code>
<ul>
<li>or another SQL database like PostgreSQL to store data in</li>
</ul>
</li>
<li><code>Spring Data JPA</code>
<ul>
<li>to simplify accessing the database from your backend code by creating entities</li>
</ul>
</li>
<li><code>Rest Repositories</code>
<ul>
<li>for your website to be able to directly access your database to via REST</li>
</ul>
</li>
</ul>
<p>After adding those, click the <code>Generate</code> button and download the zip file.
Extract the contained <code>backend</code> directory into the <code>todo-app</code> directory you created earlier, so your directory structure looks as follows:</p>
<pre><code>todo-app/
└── backend/
    ├── build.gradle
    ├── gradle
    ...
</code></pre>
<h2 id="adding-fegen-to-the-backend"><a class="header" href="#adding-fegen-to-the-backend">Adding FeGen to the backend</a></h2>
<p>In order to generate the client for your backend, you need to add the FeGen plugin to your backend project.
Add the following lines at the top of your <code>build.gradle</code> file for gradle to be able to load the FeGen web plugin:</p>
<pre><code class="language-groovy">buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath &quot;com.github.materna-se.fegen:fegen-web-gradle-plugin:1.0-RC8&quot;
    }
}
</code></pre>
<p>To actually apply FeGen to the project, add the following line below (not within) the <code>plugins { ... }</code> section:</p>
<pre><code class="language-groovy">apply plugin: 'de.materna.fegen.web'
</code></pre>
<p>To use custom endpoints with recent Spring versions, add <code>fegen-spring-util</code> as a dependency.
This is also a prerequisite for FeGen Security to work, as it provides a Spring controller with meta information about security.</p>
<pre><code class="language-groovy">dependencies {
    // ...
    implementation &quot;com.github.materna-se.fegen:fegen-spring-util:1.0-RC8&quot;
}
</code></pre>
<blockquote>
<p>FeGen Security lets you query your current permissions as a client.
To learn more, refer to the <a href="quickstart/../reference/security.html">FeGen Security</a> page of the reference documentation</p>
</blockquote>
<p>The last change to the <code>build.gradle</code> file is adding the configuration for FeGen web.
Place this below the <code>dependencies { ... }</code> section:</p>
<pre><code class="language-groovy">fegenWeb {
	scanPkg = &quot;com.example.backend&quot;
	frontendPath = &quot;../frontend/src/api-client&quot;
}
</code></pre>
<p>The first option tells FeGen where to look for your entities, repositories and controllers.
The second one tells FeGen where to put the generated typescript files that contain the client code.
We will create the referenced directory later.</p>
<blockquote>
<p>You can specify additional configuration options e.g. to control handling of dates or nullable values.
To learn what configuration options exist, refer to the <a href="quickstart/../reference/plugin_configuration/plugin_configuration.html">Plugin Configuration</a> page of the reference documentation.</p>
</blockquote>
<p>After those steps, your <code>build.gradle</code> should look as follows:</p>
<pre><code class="language-groovy">buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath &quot;com.github.materna-se.fegen:fegen-web-gradle-plugin:1.0-RC8&quot;
    }
}

plugins {
    id 'org.springframework.boot' version '2.4.4'
    id 'io.spring.dependency-management' version '1.0.11.RELEASE'
    id 'java'
}

apply plugin: 'de.materna.fegen.web'

group = 'com.example'
version = '0.0.1-SNAPSHOT'
sourceCompatibility = '11'

repositories {
    mavenCentral()
}

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'org.springframework.boot:spring-boot-starter-data-rest'
    implementation 'org.springframework.boot:spring-boot-starter-web'
    runtimeOnly 'com.h2database:h2'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
}

fegenWeb {
  scanPkg = &quot;com.example.backend&quot;
  frontendPath = &quot;../frontend/src/api-client&quot;
}

test {
    useJUnitPlatform()
}
</code></pre>
<p>To finish setting up the backend, add the <code>@Fegen</code> annotation from the FeGen runtime to your <code>BackendApplication</code>, so it looks like this:</p>
<pre><code class="language-java">@Fegen
@SpringBootApplication
public class BackendApplication {

	public static void main(String[] args) {
		SpringApplication.run(BackendApplication.class, args);
	}

}

</code></pre>
<h2 id="creating-the-frontend"><a class="header" href="#creating-the-frontend">Creating the frontend</a></h2>
<p>To create the actual website for your application, first create a directory for your frontend within the <code>todo-app</code> directory:</p>
<pre><code class="language-shell">mkdir frontend
</code></pre>
<blockquote>
<p>Usually when you create a web application using typescript, you will rely on some sort of framework like React or Angular.
These usually come with a way to quickly get started and setup up your project.
Since I do not want to presume knowledge of any specific framework, we will use plain HTML and Typescript in this guide and manually set up the typescript compilation and bundling process.</p>
</blockquote>
<p>Initialize this directory as an npm project by creating a <code>package.json</code> with the following content:</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;frontend&quot;,
  &quot;devDependencies&quot;: {
    &quot;@rollup/plugin-commonjs&quot;: &quot;^17.0.0&quot;,
    &quot;@rollup/plugin-node-resolve&quot;: &quot;^11.1.0&quot;,
    &quot;@rollup/plugin-typescript&quot;: &quot;^8.2.1&quot;,
    &quot;npm-run-all&quot;: &quot;^4.1.5&quot;,
    &quot;rollup&quot;: &quot;^2.36.2&quot;,
    &quot;serve&quot;: &quot;^11.3.2&quot;,
    &quot;tslib&quot;: &quot;^2.1.0&quot;,
    &quot;typescript&quot;: &quot;^4.2.3&quot;
  },
  &quot;dependencies&quot;: {},
  &quot;scripts&quot;: {
    &quot;build&quot;: &quot;rollup -c&quot;,
    &quot;watch&quot;: &quot;rollup -c -w&quot;,
    &quot;dev&quot;: &quot;npm-run-all --parallel start watch&quot;,
    &quot;start&quot;: &quot;serve public&quot;
  }
}
</code></pre>
<p>Your frontend project will use rollup to collect your sources and dependencies and compile everything to a single file.
The development dependency <code>serve</code> will then be used as a simple HTTP server to deliver your website.</p>
<p>Make sure you have Node.js installed and run the following to install the dependencies declared in the <code>package.json</code>:</p>
<pre><code class="language-shell">npm install
</code></pre>
<p>We still need to tell rollup how it is supposed to find and compile our source code.
Create a <code>rollup.config.js</code> in the <code>frontend</code> directory and add the following content:</p>
<pre><code class="language-javascript">import resolve from '@rollup/plugin-node-resolve';
import commonjs from '@rollup/plugin-commonjs';
import typescript from &quot;@rollup/plugin-typescript&quot;;

export default {
    input: 'src/main.ts',
    output: {
        file: 'public/bundle.js',
        format: 'iife', // immediately-invoked function expression — suitable for &lt;script&gt; tags
        sourcemap: true
    },
    plugins: [
        resolve(), // resolve dependencies (such as fegen-runtime) in node_modules
        commonjs(), // converts commonjs dependencies to ES modules
        typescript() // compile typescrip to javascript
    ]
};
</code></pre>
<p>This file tells rollup that it needs to compile the file <code>frontend/src/main.ts</code>.
Create that file and the enclosing directory, and give it the following content:</p>
<pre><code class="language-typescript">alert(&quot;Hello frontend&quot;);
</code></pre>
<p>The rollup configuration file also specifies that the output javascript should be written to <code>frontend/public/bundle.js</code>.
Create the <code>public</code> directory and an <code>index.html</code> file within and add the following content to it:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;title&gt;Todo App&lt;/title&gt;
  &lt;script type=&quot;text/javascript&quot; src=&quot;bundle.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Todo App&lt;/h1&gt;
&lt;div id=&quot;todoItems&quot;&gt;

&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>This is the base for your todo application.
You can see a <code>&lt;script&gt;</code> tag to import the compiled javascript file and a <code>&lt;div id=&quot;todoItems&quot;&gt;</code> tag where you will add your todo items once you have created your backend.</p>
<p>Run the following command to instruct rollup to compile your typescript file to bundle.js:</p>
<pre><code class="language-shell">npm run dev
</code></pre>
<p>Your <code>index.html</code> will also be served at <code>http://localhost:5000</code> by this command, so you should see a dialog box reading &quot;Hello frontend&quot; when you open that address in your browser.
Your typescript code will also be recompiled each time you change it.</p>
<blockquote>
<p>The steps for creating the frontend up until now were not specific to FeGen and will probably be simpler once you decide for a frontend framework.
However, there are two steps that you will need to perform in order for FeGen to work in the frontend.</p>
</blockquote>
<h2 id="adding-fegen-to-the-frontend"><a class="header" href="#adding-fegen-to-the-frontend">Adding FeGen to the frontend</a></h2>
<p>First, install the FeGen runtime since it will be needed by the generated code:</p>
<pre><code class="language-shell">npm install @materna-se/fegen-runtime
</code></pre>
<p>Then create the directory <code>frontend/src/api-client</code> so you have a place where FeGen can put its generated code.</p>
<p>You can now switch to your <code>backend</code> directory and run FeGen using the following Gradle command:</p>
<pre><code class="language-shell">./gradlew fegenWeb
</code></pre>
<p>Right now FeGen will warn you that it could not find any entities and no custom endpoints.
This is expected as you have not added any to your backend yet.
If you look into the <code>frontend/src/api-client</code> directory, you will find some files that FeGen has generated, although they do not have any useful content yet.
To change that by adding some entities to your backend, go to the next page.</p>
<h1 id="adding-an-entity-to-the-backend"><a class="header" href="#adding-an-entity-to-the-backend">Adding an Entity to the Backend</a></h1>
<p>In this step you will add an entity for a todo item to your backend.
This will enable you to store todo items in the database and also provide the frontend with a REST API to access and modify todo items.
With FeGen you will also be able to generate client code for your frontend to easily use that REST API.</p>
<h2 id="creating-the-entity-class"><a class="header" href="#creating-the-entity-class">Creating the entity class</a></h2>
<p>Create a java class next to the <code>BackendApplication</code>, so in the <code>backend/src/main/java/com/example/backend</code> directory and name it <code>TodoItem</code>.
Add the <code>@Entity</code> annotation to it to tell Spring and FeGen that instances of this class can be saved to the database.
Create a public field named <code>id</code> of type <code>long</code> within the class and annotate it with <code>@Id</code> and <code>@GeneratedValue</code>.
This ID will be used by FeGen to refer to specific instances of the <code>TodoItem</code> when changing or deleting them and it will be automatically assigned to an entity when it is created.
Also add a <code>String</code> field named <code>text</code> to the class that will contain the description of the todo item and a <code>boolean</code> field <code>done</code>.</p>
<p>Your class should now look like this:</p>
<pre><code class="language-java">package com.example.backend;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;

@Entity
public class TodoItem {

    @Id
    @GeneratedValue
    public long id;

    public String text;
    
    public boolean done;
}
</code></pre>
<h2 id="nullability"><a class="header" href="#nullability">Nullability</a></h2>
<p>If you execute <code>./gradlew fegenWeb</code> now, you will get the following error message and code generation will fail:</p>
<pre><code>[FeGen EntityMgr] Field &quot;text&quot; in entity &quot;com.example.backend.TodoItem&quot; is implicitly nullable.
[FeGen EntityMgr]     Please add a @Nullable annotation if this is intentional
[FeGen EntityMgr]     or add a @NotNull annotation to forbid null values
[FeGen EntityMgr]     Set implicitNullable to WARN to continue the build despite missing @Nullable annotations
</code></pre>
<blockquote>
<p>This is due to the different handling of nullability in Spring and Java versus the target languages of FeGen (Kotlin and Typescript).</p>
<p>In Java, <code>null</code> is a valid value for every non-primitive type.
There are no compile time checks whether a value may be null, so you may e.g. just access fields of a variable and if that variable actually contains null at runtime, this would just cause a <code>NullPointerException</code>.</p>
<p>On the other hand, in Kotlin and Typescript nullability is a property of the type that is in both cases declared with a <code>?</code>.
An object's field may either be nullable, in which case the compiler forces you to handle the case that it contains <code>null</code>, or it may not be nullable, in which case it may never be set it to <code>null</code>.</p>
</blockquote>
<p>Since the code generated by FeGen will be in Typescript, FeGen needs to know whether the fields of your entity may be null or not.
If they are not annotated, Spring will automatically assume that they are nullable.
FeGen could just go with that and give the fields the nullable type in the generated code, but since Typescript will by default enforce handling the null case, it is easier to work with a not nullable typed field if you know that its content may never be null.</p>
<p>In our case, <code>text</code> is the essential field that an item on a todo list is composed of, so annotate it with <code>@Column(nullable = false)</code>.</p>
<blockquote>
<p>Of course, FeGen also accepts <code>@Column(nullable = true)</code>, since you just have to explicitly state that you want your field to be nullable.
Instead of <code>@Column</code>, you may also use <code>@NotNull</code> or <code>@Nullable</code> in case you are using Spring validation anyway.
You do not need to specify nullability for primitive values, as they cannot be null even in Java (this is the case for the <code>done</code> field).
By default, the build process will stop if you have not declared nullability for an entity's field.
Although not recommended, you can configure FeGen to continue the build or even not show a warning at all.
Refer to the <a href="quickstart/../reference/plugin_configuration/configuration_options.html">Configuration Options</a> page to see how this can be done.</p>
</blockquote>
<h2 id="base-projections"><a class="header" href="#base-projections">Base Projections</a></h2>
<p>If you execute <code>./gradlew fegenWeb</code> now, you will still see a warning by FeGen:</p>
<pre><code>[FeGen ProjectionMgr] The following entities do not have a base projection:
[FeGen ProjectionMgr] TodoItem
</code></pre>
<p>Base projections are needed for technical reasons.
They are interfaces that should be nested into the entity class that they belong to.
In our case, it would look like this:</p>
<pre><code class="language-java">@Entity
public class TodoItem {
    // ...
    
    @Projection(name = &quot;baseProjection&quot;, types = {TodoItem.class})
    interface BaseProjection {
        long getId();
        String getText();
        boolean isDone();
    }
}
</code></pre>
<p>They need to meet the following criteria to be accepted by FeGen:</p>
<ul>
<li>Have a <code>@Projection</code> annotation with <code>&quot;baseProjection&quot;</code> as <code>name</code> and the corresponding entity class as only item in <code>types</code></li>
<li>Have a method defined for each property of the corresponding entity whose type is not an entity or projection
<ul>
<li>The return type of the method must match the type of the corresponding property</li>
<li>The name of the method must be the name of the getter of the property, even if no getter exists on the entity</li>
</ul>
</li>
</ul>
<blockquote>
<p>This guide does not handle using other entities or projections as entities' fields as mentioned in the second bullet point.
To learn about it, go to the <a href="quickstart/../reference/data_model/relationships.html">Relationships</a> page of the reference documentation</p>
</blockquote>
<p>Your complete entity should look like this now and FeGen should not complain about it anymore:</p>
<pre><code class="language-java">package com.example.backend;

import org.springframework.data.rest.core.config.Projection;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;

@Entity
public class TodoItem {

    @Id
    @GeneratedValue
    public long id;

    @Column(nullable = false)
    public String text;

    public boolean done;

    @Projection(name = &quot;baseProjection&quot;, types = {TodoItem.class})
    interface BaseProjection {
        long getId();
        String getText();
        boolean isDone();
    }
}
</code></pre>
<h2 id="repository"><a class="header" href="#repository">Repository</a></h2>
<p>Although FeGen is happy with your entity, it still won't generate any code to access it.
That is because you have not yet defined a repository for it, so Spring will not offer you any way to interact with your entity from your frontend.
To change that, create an interface in the same directory as your <code>TodoItem</code> entity, name it <code>TodoItemRepository</code> and have it extend <code>JpaRepository&lt;TodoItem, Long&gt;</code>:</p>
<pre><code class="language-java">package com.example.backend;

import org.springframework.data.jpa.repository.JpaRepository;

public interface TodoItemRepository extends JpaRepository&lt;TodoItem, Long&gt; {}
</code></pre>
<p>Now FeGen will output the Typescript code necessary to access your <code>TodoItem</code> entity.</p>
<h2 id="cors"><a class="header" href="#cors">CORS</a></h2>
<p>In this guide, your backend will run on port <code>8080</code>, since this is spring's default port, and your frontend will use port <code>5000</code> which is the default port of the Rollup development server.
Without any further configuration, your browser will prevent your frontend from accessing the backend's API, because it will enforce the rules for Cross Origin Resource Sharing.
You will have to configure your backend to explicitly allow access from your frontend.
Create a class named <code>Config</code>, place it in the same directory as the other classes you created and enter the following content:</p>
<pre><code class="language-java">package com.example.backend;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.rest.core.config.RepositoryRestConfiguration;
import org.springframework.data.rest.webmvc.config.RepositoryRestConfigurer;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class Config {

    @Bean
    public WebMvcConfigurer webMvcConfigurer() {
        return new WebMvcConfigurer() {
            @Override
            public void addCorsMappings(CorsRegistry registry) {
                configureCors(registry);
            }
        };
    }

    @Bean
    public RepositoryRestConfigurer repositoryRestConfigurer() {
        return new RepositoryRestConfigurer() {
            @Override
            public void configureRepositoryRestConfiguration(RepositoryRestConfiguration config, CorsRegistry cors) {
                configureCors(cors);
            }
        };
    }

    private void configureCors(CorsRegistry registry) {
        registry.addMapping(&quot;/**&quot;)
                .allowedOrigins(&quot;http://localhost:5000&quot;)
                .allowedMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;);
    }
}
</code></pre>
<p>The two methods returning Configurers will ensure that each response to a request from your frontend will include an HTTP header that declares that this access is allowed.
The second method is important for us as it includes that header when calling repository endpoints to access entities.
The first method is not strictly necessary right now, but will add the header if you create and use custom endpoints.</p>
<p>This is all you have to do for the backend.
Go to the next page to learn how to use the code generated by FeGen in the frontend to finish your web app.</p>
<h1 id="creating-the-frontend-1"><a class="header" href="#creating-the-frontend-1">Creating the Frontend</a></h1>
<p>On this page you will create the website that will display the actual todo list and access the backend using FeGen to store the todo list items.</p>
<h2 id="instantiate-the-api-client"><a class="header" href="#instantiate-the-api-client">Instantiate the API client</a></h2>
<p>If you have not yet done it after the last step, run <code>./gradlew fegenWeb</code> in the <code>backend</code> directory.
You should see generated files in the <code>frontend/src/api-client</code> directory.</p>
<p>The code generated by FeGen does not know under which URL the backend can be found, so you will need to pass that information when instantiating the api client.</p>
<p>Replace the content of <code>frontend/src/main.ts</code> with the following:</p>
<pre><code class="language-typescript">import {ApiClient} from &quot;./api-client/ApiClient&quot;;

const apiClient = new ApiClient(undefined, &quot;http://localhost:8080&quot;);
</code></pre>
<p>The second line creates a new instance of <code>ApiClient</code>, which is generated by FeGen.
The first parameter can be an instance of <code>RequestAdapter</code> to override the behavior when making requests to the backend.
The latter parameter however is usually more important, as it specifies the base URL where the api client can find the backend.
Since you will run the backend on the same machine for now and Spring applications by default run on port <code>8080</code> and do not offer HTTPS, the base URL is <code>http://localhost:8080</code> in this case.</p>
<blockquote>
<p>In a production environment, you will need to change that base url.
Depending on your use case, you may want to use the same web server to deliver your frontend and handle your backend api calls.
In that case, it is a good idea to set a base path in Spring that the paths of all your API URLs start with.
To learn what you need consider when using one, refer to the <a href="quickstart/../reference/base_path.html">Base Path</a> page of the reference documentation.</p>
</blockquote>
<h2 id="displaying-the-empty-list-of-todos"><a class="header" href="#displaying-the-empty-list-of-todos">Displaying the (empty) List of Todos</a></h2>
<p>To show the todo items when opening the web app, append the following code to your <code>frontend/src/main.ts</code>:</p>
<pre><code class="language-typescript">/**
 * Create an HTML element representing the given todoItem
 */
const createTodoElement = (todoItem: TodoItem): HTMLElement =&gt; {
    const todoEl = document.createElement(&quot;div&quot;);

    const doneEl = document.createElement(&quot;input&quot;);
    doneEl.type = &quot;checkbox&quot;;
    doneEl.checked = todoItem.done;
    todoEl.appendChild(doneEl);

    const textEl = document.createElement(&quot;span&quot;);
    textEl.textContent = todoItem.text;
    todoEl.appendChild(textEl);
    
    return todoEl;
}

const loadTodoItems = () =&gt; {
    // Get the &lt;div&gt; element that will contain the items
    const listEl = document.querySelector(&quot;#todoItems&quot;)!;
    // Remove old items if there have been any
    listEl.innerHTML = &quot;&quot;;
    apiClient.todoItemClient.readAll().then(todoItems =&gt; {
        for (const todoItem of todoItems.items) {
            const itemEl = createTodoElement(todoItem);
            listEl.appendChild(itemEl);
        }
    }).catch(err =&gt; {
        console.error(&quot;Failed to fetch todo items&quot;, err);
        alert(&quot;Failed to fetch todo items&quot;)
    });
};
</code></pre>
<p>The line starting with <code>apiClient</code> refers to the variable you created in the previous step.
It contains an instance of a class generated by FeGen.
That class has a member called <code>todoItemClient</code> that contains method for basic CRUD functionality for the TodoItem entity like reading all instances of that entity.
FeGen will create such a member for each Entity / Repository combination you define.</p>
<p>The <code>readAll</code> method returns all todo item entity that currently exist in the backend.
It does not return them as a plain array though, but as a <code>Promise</code>, so the execution of frontend code is not interrupted while the browser is waiting for the backend to respond.
Using the <code>then</code> method of that <code>Promise</code>, we can specify what to do with the todo items once they are successfully retrieved from the backend.
The <code>todoItems</code> parameter is correctly typed using a type generated by FeGen, so you can enjoy autocompletion while iterating through the contained <code>items</code> array and accessing the <code>text</code> property that you have defined for that entity in the backend.
In case something goes wrong while retrieving the todo items (for example, if the backend server cannot be reached) the callback passed to the <code>catch</code> block is called, and you will see a dialog box.</p>
<blockquote>
<p>There are various ways besides a simple call to <code>readAll</code> to retrieve entities from the backend.
For example, you can pass sorting and paging parameters to <code>readAll</code> to only retrieve a sublist of a certain length in a specific order.
You can also create projections in the backend which specify a set of fields to return, which enables you to query related entities in one step.
With repository and custom searches you are able to filter the entities that are returned by the backend.
To learn how you can use these options with FeGen, refer to the <a href="quickstart/../reference/retrieving/intro.html">Retrieving Data</a> page of the reference documentation</p>
</blockquote>
<p>To actually run the code, you need to call the function that contains it, so append the following line at the bottom of <code>main.ts</code>:</p>
<pre><code class="language-typescript">const onReady = () =&gt; {
    loadTodoItems();
};

if (document.readyState !== 'loading') {
    // HTML is already completely initialized
    onReady();
} else {
    // Wait until initialization has completed
    document.addEventListener('DOMContentLoaded', onReady);
}
</code></pre>
<p>You can start the web app by running <code>./gradlew bootRun</code> in the <code>backend</code> directory and at the same time running <code>npm run dev</code> in the <code>frontend</code> directory.
However, if you open <code>http://localhost:5000/</code> in your browser, you will only see the headline, because there aren't any todo items yet.</p>
<h2 id="adding-todo-items"><a class="header" href="#adding-todo-items">Adding Todo Items</a></h2>
<p>To add todo items, we first need an input field to enter the new item's text and a button to trigger the creation.
Add the following HTML just below the <code>&lt;h1&gt;Todo App&lt;/h1&gt;</code> tag:</p>
<pre><code class="language-html">&lt;div&gt;
  &lt;label&gt;
    New Todo:
    &lt;input id=&quot;newTodoText&quot; type=&quot;text&quot; /&gt;
  &lt;/label&gt;
  &lt;button id=&quot;newTodoButton&quot;&gt;Create&lt;/button&gt;
&lt;/div&gt;
</code></pre>
<p>Now we still need to give that button some functionality.
Add the following code between the <code>loadTodoItems</code> and the <code>onReady</code> function:</p>
<pre><code class="language-typescript">const createTodo = async () =&gt; {
    const text = document.querySelector&lt;HTMLInputElement&gt;(&quot;#newTodoText&quot;).value;
    await apiClient.todoItemClient.create({
        text,
        done: false
    });
    // Use async function and await create result to avoid loading items before creation has finished
    loadTodoItems();
};
</code></pre>
<p>This will read the text out of the input element and use the code generated by FeGen to create a new instance of the todo item entity with that text in the backend.
After it waits for that operation to complete, it loads the todo items from the server again and updates the list.</p>
<blockquote>
<p>If you are developing a real application, you should probably wrap the call to <code>create</code> together with the <code>await</code> in a try block and let the user know if an error occurred in the corresponding <code>catch</code> block.
That is the async function equivalent to the error handling you did with <code>catch</code> when fetching all todo items.</p>
</blockquote>
<p>To run this code whenever the <code>Create</code> button is clicked, add the following line at the end of the <code>onReady</code> function body:</p>
<pre><code class="language-typescript">document.querySelector&lt;HTMLButtonElement&gt;(&quot;#newTodoButton&quot;).onclick = createTodo;
</code></pre>
<p>If you left <code>./gradlew bootRun</code> and <code>npm run dev</code> running, you will now be able to add todo items by entering a text and pressing <code>Create</code> after reloading the page once.
The todo items' texts should then appear below.
Try to reload the page or close and open the browser, and you will see that the todo items appear again because they are persisted in the backend.</p>
<blockquote>
<p>If you stop and restart the backend, the todo items will be lost, since you are currently only using the h2 in-memory database.
For applications used in a production environment, you should use a persistent database such as PostgreSQL.</p>
</blockquote>
<h2 id="modifying-todo-items"><a class="header" href="#modifying-todo-items">Modifying Todo Items</a></h2>
<p>You can already click the checkbox in front of each todo item to mark it as done, but that change will not be saved if you reload the application.
To make the changes persistent, add the following code between the lines <code>doneEl.checked = todoItem.done;</code> and <code>todoEl.appendChild(doneEl);</code> within the <code>createTodoElement</code> function's body:</p>
<pre><code class="language-typescript">doneEl.onchange = async () =&gt; {
  await apiClient.todoItemClient.update({
    ...todoItem,
    done: doneEl.checked
  });
  loadTodoItems();
};
</code></pre>
<p>Now each time the checkbox is clicked, the frontend will propagate the change to the backend, so you can reload the web app and still see which todos are done.</p>
<blockquote>
<p>Keep in mind that the <code>todoItem</code> variable does not only contain the <code>text</code> and <code>done</code> fields, but also the <code>id</code> field which is necessary for Spring to find the correct entity to modify.
This is why just replacing <code>...todoItem</code> by <code>text: todoItem.text</code> won't work.</p>
</blockquote>
<h2 id="deleting-todo-items"><a class="header" href="#deleting-todo-items">Deleting Todo Items</a></h2>
<p>Now that we can create todo items and mark them as done, there should also be a way to get rid of them.
Add the following code just above the <code>return todoEl</code> within the <code>createTodoElement</code> function's body:</p>
<pre><code class="language-typescript">const deleteButtonEl = document.createElement(&quot;button&quot;);
deleteButtonEl.textContent = &quot;X&quot;;
deleteButtonEl.onclick = async () =&gt; {
    await apiClient.todoItemClient.delete(todoItem);
    loadTodoItems();
};
todoEl.appendChild(deleteButtonEl);
</code></pre>
<p>The items in the list will now not only consist of a text, but also a button to delete the todo item.</p>
<h1 id="congratulations"><a class="header" href="#congratulations">Congratulations</a></h1>
<p>You completed the FeGen quick start guide.
You should now know have a basic understanding about what FeGen does and how you can use it to write a web app.
However, FeGen has a lot more to offer than what was included in the quick start guide.
Go to the next page to learn more.</p>
<h1 id="reference-documentation"><a class="header" href="#reference-documentation">Reference Documentation</a></h1>
<h1 id="entities"><a class="header" href="#entities">Entities</a></h1>
<ul>
<li>Repository needed</li>
<li>Annotated with <code>@Entity</code></li>
</ul>
<h2 id="java"><a class="header" href="#java">Java</a></h2>
<h2 id="kotlin"><a class="header" href="#kotlin">Kotlin</a></h2>
<ul>
<li>It is still necessary to mark entity columns explicitly as nullable or not null</li>
</ul>
<p>(Base) Projection definitions</p>
<h2 id="base-projection"><a class="header" href="#base-projection">Base projection</a></h2>
<p>To use generated code when developing Android apps, create a library project in Android Studio and copy the contents of fegen-kotlin/fegen-kotlin-android-runtime to the source directory into the package de.materna.fegen.adapter.android.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
