<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>FeGen</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="intro.html">Introduction</a></li><li class="chapter-item expanded "><a href="quickstart/intro.html"><strong aria-hidden="true">1.</strong> Quick Start Guide</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="quickstart/setup.html"><strong aria-hidden="true">1.1.</strong> Setup</a></li><li class="chapter-item expanded "><a href="quickstart/backend.html"><strong aria-hidden="true">1.2.</strong> Backend</a></li><li class="chapter-item expanded "><a href="quickstart/frontend.html"><strong aria-hidden="true">1.3.</strong> Frontend</a></li><li class="chapter-item expanded "><a href="quickstart/further_reading.html"><strong aria-hidden="true">1.4.</strong> Further Reading</a></li></ol></li><li class="chapter-item expanded "><a href="reference/intro.html"><strong aria-hidden="true">2.</strong> Reference Documentation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/plugin_configuration/intro.html"><strong aria-hidden="true">2.1.</strong> Plugin Configuration</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/plugin_configuration/gradle.html"><strong aria-hidden="true">2.1.1.</strong> Gradle</a></li><li class="chapter-item expanded "><a href="reference/plugin_configuration/maven.html"><strong aria-hidden="true">2.1.2.</strong> Maven</a></li><li class="chapter-item expanded "><a href="reference/plugin_configuration/configuration_options.html"><strong aria-hidden="true">2.1.3.</strong> Configuration Options</a></li><li class="chapter-item expanded "><a href="reference/plugin_configuration/backend.html"><strong aria-hidden="true">2.1.4.</strong> Backend Configuration</a></li></ol></li><li class="chapter-item expanded "><a href="reference/data_model/intro.html"><strong aria-hidden="true">2.2.</strong> Data Model</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/data_model/entities.html"><strong aria-hidden="true">2.2.1.</strong> Entities</a></li><li class="chapter-item expanded "><a href="reference/data_model/pojos.html"><strong aria-hidden="true">2.2.2.</strong> POJOs</a></li><li class="chapter-item expanded "><a href="reference/data_model/relationships.html"><strong aria-hidden="true">2.2.3.</strong> Relationships</a></li><li class="chapter-item expanded "><a href="reference/data_model/custom_endpoints.html"><strong aria-hidden="true">2.2.4.</strong> Custom Endpoints</a></li><li class="chapter-item expanded "><a href="reference/data_model/embeddables.html"><strong aria-hidden="true">2.2.5.</strong> Embeddables</a></li><li class="chapter-item expanded "><a href="reference/data_model/fegen_ignore.html"><strong aria-hidden="true">2.2.6.</strong> @FegenIgnore</a></li></ol></li><li class="chapter-item expanded "><a href="reference/retrieving/intro.html"><strong aria-hidden="true">2.3.</strong> Retrieving Data</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/retrieving/paging_sorting.html"><strong aria-hidden="true">2.3.1.</strong> Paging and Sorting</a></li><li class="chapter-item expanded "><a href="reference/retrieving/projections.html"><strong aria-hidden="true">2.3.2.</strong> Projections</a></li><li class="chapter-item expanded "><a href="reference/retrieving/repository_searches.html"><strong aria-hidden="true">2.3.3.</strong> Repository Searches</a></li><li class="chapter-item expanded "><a href="reference/retrieving/custom_searches.html"><strong aria-hidden="true">2.3.4.</strong> Custom Searches</a></li></ol></li><li class="chapter-item expanded "><a href="reference/targets/intro.html"><strong aria-hidden="true">2.4.</strong> Targets</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/targets/typescript.html"><strong aria-hidden="true">2.4.1.</strong> Typescript</a></li><li class="chapter-item expanded "><a href="reference/targets/kotlin.html"><strong aria-hidden="true">2.4.2.</strong> Kotlin</a></li></ol></li><li class="chapter-item expanded "><a href="reference/security.html"><strong aria-hidden="true">2.5.</strong> Security</a></li><li class="chapter-item expanded "><a href="reference/pitfalls.html"><strong aria-hidden="true">2.6.</strong> Pitfalls</a></li></ol></li><li class="chapter-item expanded "><a href="developing/intro.html"><strong aria-hidden="true">3.</strong> Developing FeGen</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="developing/building.html"><strong aria-hidden="true">3.1.</strong> Building</a></li><li class="chapter-item expanded "><a href="developing/architecture.html"><strong aria-hidden="true">3.2.</strong> Architecture</a></li><li class="chapter-item expanded "><a href="developing/local_usage.html"><strong aria-hidden="true">3.3.</strong> Using a Custom Build Locally</a></li><li class="chapter-item expanded "><a href="developing/contributing.html"><strong aria-hidden="true">3.4.</strong> Contributing</a></li><li class="chapter-item expanded "><a href="developing/publishing.html"><strong aria-hidden="true">3.5.</strong> Publishing</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">FeGen</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>FeGen helps you write web and mobile apps with Spring Boot backends.
It does so by generating client code based on your Spring server, so you can access your Spring Data REST API in a type safe manner.
Typescript and Kotlin are supported as frontend languages, so you can use FeGen when creating a web app, a native Android app or another Spring application.</p>
<h2 id="idea"><a class="header" href="#idea">Idea</a></h2>
<p>With Spring Data Rest it is already very convenient to create a REST API to persist data by just specifying the data model using entities like this one:</p>
<pre><code class="language-java">@Entity
public class Country {
    
    public long id;
    
    public String name;
    
    public int population;

    @OneToMany(mappedBy = &quot;country&quot;)
    public List&lt;City&gt; cities;
}
</code></pre>
<p>You just need to specify matching repositories, and Spring Data Rest will provide you with a HATEOAS API that supports all CRUD operations:</p>
<pre><code class="language-java">public interface CountryRepository extends JpaRepository&lt;Country, Long&gt; {}
</code></pre>
<p>If you want to e.g. create a new country from within a web application, you can now use the following code:</p>
<pre><code class="language-typescript">const counrty = await fetch(&quot;http://example.com/countries&quot;, {
    method: &quot;POST&quot;,
    body: {
        name: &quot;Germany&quot;,
        population: 80_000_000,
        cities: []
    }
});
</code></pre>
<p>However, creating REST requests that conform to the HATEOAS that Spring expects can be quite cumbersome.
This is how you would add a city to a country:</p>
<pre><code class="language-typescript">fetch(&quot;http://example.com/cities&quot;, {
    method: &quot;POST&quot;,
    body: {
        name: &quot;Dortmund&quot;,
        population: 600_000,
        counrty: counrty._links.self.href
    }
})
</code></pre>
<p>Although HATEOAS is not overly complicated, it is easy to make a mistake e.g. by misspelling the URL or a property name, using the wrong method or supplying an object as a related entity instead of a link.
Also, if you change your API later on, you will have to manually check for all the places in your frontend where you have used it.</p>
<p>This is where FeGen comes into play.
You can add it to your Spring Boot project, and it will look at the entities and repositories you defined and generate frontend code in Typescript or Kotlin so you can access your API without worrying about the HATEOAS details:</p>
<pre><code class="language-typescript">const country = await apiClient.countryClient.create({
    name: &quot;germany&quot;,
    population: 80_000_000,
    cities: []
});

apiClient.cityClient.create({
    name: &quot;Dortmund&quot;,
    population: 600_000,
    country
});
</code></pre>
<p>As you can see, this has multiple advantages:</p>
<ul>
<li>You do not need to know how HATEOAS works</li>
<li>Generated types for entities prevent mistakes and give you auto completion</li>
<li>When you change your API, obsolete usages in your frontend will cause compiler errors, so you can easily spot and fix them</li>
<li>The code is more readable as it better conveys its intent</li>
<li>Less boilerplate code</li>
</ul>
<p>As with Spring and Spring Data REST, with FeGen, you are not constrained to simple CRUD operations.
You can use paging, sorting, custom searches and projections to access your data.
Moreover, FeGen also generates code to access the methods within controllers.</p>
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<p>This is how a full stack application using FeGen may be structured:</p>
<p><img src="./architecture.svg" alt="Architecture" /></p>
<p>In the simplest case, you can just define some entities <em>(1)</em> as well as the corresponding repositories <em>(2)</em> and FeGen enables you to read and modify those entities from within your frontend code <em>(3)</em> as in the code examples you just saw.
If you need more fine-grained control, you can also define your own endpoints in a Spring controller <em>(4)</em> which may use entities or plain java classes that you defined <em>(5)</em> and FeGen will generate corresponding types and methods to invoke those endpoints <em>(6)</em>.
Finally, if you need to access an endpoint in a way that FeGen does not currently support (such as file up- or download), you can of course always directly access your Spring server from your frontend <em>(7)</em>.</p>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h2>
<p>If you are new to FeGen, please follow the <a href="./quickstart/intro.html">Quick Start Guide</a> to get an idea of how FeGen works and how you can use it.
Once you finished the <a href="./quickstart/intro.html">Quick Start Guide</a>, you can go more into detail and e.g. learn how to use FeGen to access your backend from Android or another Spring application, by referring to the <a href="./reference/intro.html">Reference Documentation</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-start-guide"><a class="header" href="#quick-start-guide">Quick Start Guide</a></h1>
<p>On the following pages you will learn how to create a simple web application using Spring, FeGen and Typescript.
It will allow you to create, view, edit and delete items from a todo list.
This guide is recommended even if you use case differs, e.g. because you want to use Kotlin in the backend or want to generate code for a Kotlin client like an Android app or another spring application.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>In order to follow this guide, you will need to have a basic understanding of Java, Spring Boot and Typescript.</p>
<p>You will also need to have Node.js installed to create the frontend.
Go to <a href="https://nodejs.org/">https://nodejs.org/</a> in order to download and install Node.js for your operating system, if you haven't already.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup"><a class="header" href="#setup">Setup</a></h1>
<p>In this step you will initialize your backend and frontend project and configure them to use FeGen.</p>
<p>The first thing you should do is create a directory for your project.</p>
<pre><code class="language-shell">mkdir todo-app
</code></pre>
<h2 id="creating-the-backend"><a class="header" href="#creating-the-backend">Creating the backend</a></h2>
<p>To create the web server for your application, you can use the spring initializr.
Go to <a href="https://start.spring.io/">https://start.spring.io/</a>.
Select the <code>Gradle Project</code> and <code>Java</code> radio buttons, change the artifact metadata to <code>backend</code> (The name will automaticaly change as well) and choose Java <code>14</code> or above.</p>
<blockquote>
<p>FeGen also supports Maven and Kotlin, but they are not used in this guide in order to keep it simple.
If you want to know how to configure FeGen with Maven, refer to the <a href="quickstart/../reference/plugin_configuration/maven.html">Maven</a> page of the reference documentation.</p>
</blockquote>
<p>To use your Spring Boot application as a backend for your web application, you will need to add the following dependencies using the button in the top right:</p>
<ul>
<li><code>Spring Web</code>
<ul>
<li>to allow your website to communicate with the backend using REST</li>
</ul>
</li>
<li><code>H2 Database</code>
<ul>
<li>or another SQL database like PostgreSQL to store data in</li>
</ul>
</li>
<li><code>Spring Data JPA</code>
<ul>
<li>to simplify accessing the database from your backend code by creating entities</li>
</ul>
</li>
<li><code>Rest Repositories</code>
<ul>
<li>for your website to be able to directly access your database to via REST</li>
</ul>
</li>
<li><code>Spring Security</code></li>
</ul>
<p>After adding those, click the <code>Generate</code> button and download the zip file.
Extract the contained <code>backend</code> directory into the <code>todo-app</code> directory you created earlier, so your directory structure looks as follows:</p>
<pre><code>todo-app/
└── backend/
    ├── build.gradle
    ├── gradle
    ...
</code></pre>
<h2 id="adding-fegen-to-the-backend"><a class="header" href="#adding-fegen-to-the-backend">Adding FeGen to the backend</a></h2>
<p>In order to generate the client for your backend, you need to add the FeGen plugin to your backend project.
Add the following lines at the top of your <code>build.gradle</code> file for gradle to be able to load the FeGen web plugin:</p>
<pre><code class="language-groovy">buildscript {
	repositories {
		mavenCentral()
	}
	dependencies {
		classpath &quot;com.github.materna-se.fegen:fegen-web-gradle-plugin:1.0-RC8&quot;
	}
}
</code></pre>
<p>To actually apply FeGen to the project, add the following line below (not within) the <code>plugins { ... }</code> section:</p>
<pre><code class="language-groovy">apply plugin: 'de.materna.fegen.web'
</code></pre>
<p>To use custom endpoints with recent Spring versions, add <code>fegen-spring-util</code> as a dependency.
This is also a prerequisite for FeGen Security to work, as it provides a Spring controller with meta information about security.</p>
<pre><code class="language-groovy">dependencies {
    // ...
    implementation &quot;com.github.materna-se.fegen:fegen-spring-util:1.0-RC8&quot;
}
</code></pre>
<blockquote>
<p>FeGen Security lets you query your current permissions as a client.
To learn more, refer to the <a href="quickstart/../reference/security.html">FeGen Security</a> page of the reference documentation</p>
</blockquote>
<p>The last change to the <code>build.gradle</code> file is adding the configuration for FeGen web.
Place this below the <code>dependencies { ... }</code> section:</p>
<pre><code class="language-groovy">fegenWeb {
	scanPkg = &quot;com.example.backend&quot;
	frontendPath = &quot;../frontend/src/api-client&quot;
}
</code></pre>
<p>The first option tells FeGen where to look for your entities, repositories and controllers.
The second one tells FeGen where to put the generated typescript files that contain the client code.
We will create the referenced directory later.</p>
<blockquote>
<p>You can specify additional configuration options e.g. to control handling of dates or nullable values.
To learn what configuration options exist, refer to the <a href="quickstart/../reference/plugin_configuration/plugin_configuration.html">Plugin Configuration</a> page of the reference documentation.</p>
</blockquote>
<p>After those steps, your <code>build.gradle</code> should look as follows:</p>
<pre><code class="language-groovy">buildscript {
	repositories {
		mavenCentral()
	}
	dependencies {
		classpath &quot;com.github.materna-se.fegen:fegen-web-gradle-plugin:1.0-RC8&quot;
	}
}

plugins {
	id 'org.springframework.boot' version '2.6.0'
	id 'io.spring.dependency-management' version '1.0.11.RELEASE'
	id 'java'
}

apply plugin: 'de.materna.fegen.web'

group = &quot;com.example&quot;
version = &quot;0.0.1-SNAPSHOT&quot;
sourceCompatibility = '14'

repositories {
    mavenCentral()
}

dependencies {
	implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
	implementation 'org.springframework.boot:spring-boot-starter-data-rest'
	implementation 'org.springframework.boot:spring-boot-starter-security'
	implementation 'org.springframework.boot:spring-boot-starter-web'
	runtimeOnly 'com.h2database:h2'
	testImplementation 'org.springframework.boot:spring-boot-starter-test'
	testImplementation 'org.springframework.security:spring-security-test'
	implementation &quot;com.github.materna-se.fegen:fegen-spring-util:1.0-RC8&quot;
}

test {
	useJUnitPlatform()
}

fegenWeb {
    scanPkg = &quot;com.example.backend&quot;
    frontendPath = &quot;../frontend/src/api-client&quot;
}
</code></pre>
<p>To finish setting up the backend, add the <code>@Fegen</code> annotation from the FeGen runtime to your <code>BackendApplication</code>, so it looks like this:</p>
<pre><code class="language-java">@Fegen
@SpringBootApplication
public class BackendApplication {

	public static void main(String[] args) {
		SpringApplication.run(BackendApplication.class, args);
	}

}
</code></pre>
<h2 id="creating-the-frontend"><a class="header" href="#creating-the-frontend">Creating the frontend</a></h2>
<p>To create the actual website for your application, first create a directory for your frontend within the <code>todo-app</code> directory:</p>
<pre><code class="language-shell">mkdir frontend
</code></pre>
<blockquote>
<p>Usually when you create a web application using typescript, you will rely on some sort of framework like React or Angular.
These usually come with a way to quickly get started and setup up your project.
Since I do not want to presume knowledge of any specific framework, we will use plain HTML and Typescript in this guide and manually set up the typescript compilation and bundling process.</p>
</blockquote>
<p>Initialize this directory as an npm project by creating a <code>package.json</code> with the following content:</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;frontend&quot;,
  &quot;devDependencies&quot;: {
    &quot;@rollup/plugin-commonjs&quot;: &quot;^17.0.0&quot;,
    &quot;@rollup/plugin-node-resolve&quot;: &quot;^11.1.0&quot;,
    &quot;@rollup/plugin-typescript&quot;: &quot;^8.2.1&quot;,
    &quot;npm-run-all&quot;: &quot;^4.1.5&quot;,
    &quot;rollup&quot;: &quot;^2.36.2&quot;,
    &quot;serve&quot;: &quot;^11.3.2&quot;,
    &quot;tslib&quot;: &quot;^2.1.0&quot;,
    &quot;typescript&quot;: &quot;^4.2.3&quot;
  },
  &quot;dependencies&quot;: {},
  &quot;scripts&quot;: {
    &quot;build&quot;: &quot;rollup -c&quot;,
    &quot;watch&quot;: &quot;rollup -c -w&quot;,
    &quot;dev&quot;: &quot;npm-run-all --parallel start watch&quot;,
    &quot;start&quot;: &quot;serve public&quot;
  }
}
</code></pre>
<p>Your frontend project will use rollup to collect your sources and dependencies and compile everything to a single file.
The development dependency <code>serve</code> will then be used as a simple HTTP server to deliver your website.</p>
<p>Make sure you have Node.js installed and run the following to install the dependencies declared in the <code>package.json</code>:</p>
<pre><code class="language-shell">npm install
</code></pre>
<p>We still need to tell rollup how it is supposed to find and compile our source code.
Create a <code>rollup.config.js</code> in the <code>frontend</code> directory and add the following content:</p>
<pre><code class="language-javascript">import resolve from '@rollup/plugin-node-resolve';
import commonjs from '@rollup/plugin-commonjs';
import typescript from &quot;@rollup/plugin-typescript&quot;;

export default {
    input: 'src/main.ts',
    output: {
        file: 'public/bundle.js',
        format: 'iife', // immediately-invoked function expression — suitable for &lt;script&gt; tags
        sourcemap: true
    },
    plugins: [
        resolve(), // resolve dependencies (such as fegen-runtime) in node_modules
        commonjs(), // converts commonjs dependencies to ES modules
        typescript() // compile typescrip to javascript
    ]
};
</code></pre>
<p>This file tells rollup that it needs to compile the file <code>frontend/src/main.ts</code>.
Create that file and the enclosing directory, and give it the following content:</p>
<pre><code class="language-typescript">alert(&quot;Hello frontend&quot;);
</code></pre>
<p>The rollup configuration file also specifies that the output javascript should be written to <code>frontend/public/bundle.js</code>.
Create the <code>public</code> directory and an <code>index.html</code> file within and add the following content to it:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;title&gt;Todo App&lt;/title&gt;
  &lt;script type=&quot;text/javascript&quot; src=&quot;bundle.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Todo App&lt;/h1&gt;
&lt;div id=&quot;todoItems&quot;&gt;

&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>This is the base for your todo application.
You can see a <code>&lt;script&gt;</code> tag to import the compiled javascript file and a <code>&lt;div id=&quot;todoItems&quot;&gt;</code> tag where you will add your todo items once you have created your backend.</p>
<p>Run the following command to instruct rollup to compile your typescript file to bundle.js:</p>
<pre><code class="language-shell">npm run dev
</code></pre>
<p>Your <code>index.html</code> will also be served at <code>http://localhost:5000</code> by this command, so you should see a dialog box reading &quot;Hello frontend&quot; when you open that address in your browser.
Your typescript code will also be recompiled each time you change it.</p>
<blockquote>
<p>The steps for creating the frontend up until now were not specific to FeGen and will probably be simpler once you decide for a frontend framework.
However, there are two steps that you will need to perform in order for FeGen to work in the frontend.</p>
</blockquote>
<h2 id="adding-fegen-to-the-frontend"><a class="header" href="#adding-fegen-to-the-frontend">Adding FeGen to the frontend</a></h2>
<p>First, install the FeGen runtime since it will be needed by the generated code:</p>
<pre><code class="language-shell">npm install @materna-se/fegen-runtime
</code></pre>
<p>Then create the directory <code>frontend/src/api-client</code> so you have a place where FeGen can put its generated code.</p>
<p>You can now switch to your <code>backend</code> directory and run FeGen using the following Gradle command:</p>
<pre><code class="language-shell">./gradlew fegenWeb
</code></pre>
<p>Right now FeGen will warn you that it could not find any entities and no custom endpoints.
This is expected as you have not added any to your backend yet.
If you look into the <code>frontend/src/api-client</code> directory, you will find some files that FeGen has generated, although they do not have any useful content yet.
To change that by adding some entities to your backend, go to the next page.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adding-an-entity-to-the-backend"><a class="header" href="#adding-an-entity-to-the-backend">Adding an Entity to the Backend</a></h1>
<p>In this step you will add an entity for a todo item to your backend.
This will enable you to store todo items in the database and also provide the frontend with a REST API to access and modify todo items.
With FeGen you will also be able to generate client code for your frontend to easily use that REST API.</p>
<h2 id="creating-the-entity-class"><a class="header" href="#creating-the-entity-class">Creating the entity class</a></h2>
<p>Create a java class next to the <code>BackendApplication</code>, so in the <code>backend/src/main/java/com/example/backend</code> directory and name it <code>TodoItem</code>.
Add the <code>@Entity</code> annotation to it to tell Spring and FeGen that instances of this class can be saved to the database.
Create a public field named <code>id</code> of type <code>long</code> within the class and annotate it with <code>@Id</code> and <code>@GeneratedValue</code>.
This ID will be used by FeGen to refer to specific instances of the <code>TodoItem</code> when changing or deleting them and it will be automatically assigned to an entity when it is created.
Also add a <code>String</code> field named <code>text</code> to the class that will contain the description of the todo item and a <code>boolean</code> field <code>done</code>.
Since we are using Java for this guide, you also have to add the default <code>getter</code> and <code>setter</code> methods for all fields</p>
<p>Your class should now look like this:</p>
<pre><code class="language-java">package com.example.backend;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;

@Entity
public class TodoItem {

    @Id
    @GeneratedValue
    public long id;

    public String text;

    public boolean done;

    public long getId() {
      return id;
    }

    public void setId(long id) {
      this.id = id;
    }

    public String getText() {
        return text;
    }

    public void setText(String text) {
        this.text = text;
    }

    public boolean isDone() {
        return done;
    }

    public void setDone(boolean done) {
        this.done = done;
    }
}
</code></pre>
<h2 id="nullability"><a class="header" href="#nullability">Nullability</a></h2>
<p>If you execute <code>./gradlew fegenWeb</code> now, you will get the following error message and code generation will fail:</p>
<pre><code>[FeGen EntityMgr] Field &quot;text&quot; in entity &quot;com.example.backend.TodoItem&quot; is implicitly nullable.
[FeGen EntityMgr]     Please add a @Nullable annotation if this is intentional
[FeGen EntityMgr]     or add a @NotNull annotation to forbid null values
[FeGen EntityMgr]     Set implicitNullable to WARN to continue the build despite missing @Nullable annotations
</code></pre>
<blockquote>
<p>This is due to the different handling of nullability in Spring and Java versus the target languages of FeGen (Kotlin and Typescript).</p>
<p>In Java, <code>null</code> is a valid value for every non-primitive type.
There are no compile time checks whether a value may be null, so you may e.g. just access fields of a variable and if that variable actually contains null at runtime, this would just cause a <code>NullPointerException</code>.</p>
<p>On the other hand, in Kotlin and Typescript nullability is a property of the type that is in both cases declared with a <code>?</code>.
An object's field may either be nullable, in which case the compiler forces you to handle the case that it contains <code>null</code>, or it may not be nullable, in which case it may never be set it to <code>null</code>.</p>
</blockquote>
<p>Since the code generated by FeGen will be in Typescript, FeGen needs to know whether the fields of your entity may be null or not.
If they are not annotated, Spring will automatically assume that they are nullable.
FeGen could just go with that and give the fields the nullable type in the generated code, but since Typescript will by default enforce handling the null case, it is easier to work with a not nullable typed field if you know that its content may never be null.</p>
<p>In our case, <code>text</code> is the essential field that an item on a todo list is composed of, so annotate it with <code>@Column(nullable = false)</code>.</p>
<blockquote>
<p>Of course, FeGen also accepts <code>@Column(nullable = true)</code>, since you just have to explicitly state that you want your field to be nullable.
Instead of <code>@Column</code>, you may also use <code>@NotNull</code> or <code>@Nullable</code> in case you are using Spring validation anyway.
You do not need to specify nullability for primitive values, as they cannot be null even in Java (this is the case for the <code>done</code> field).
By default, the build process will stop if you have not declared nullability for an entity's field.
Although not recommended, you can configure FeGen to continue the build or even not show a warning at all.
Refer to the <a href="quickstart/../reference/plugin_configuration/configuration_options.html">Configuration Options</a> page to see how this can be done.</p>
</blockquote>
<h2 id="base-projections"><a class="header" href="#base-projections">Base Projections</a></h2>
<p>If you execute <code>./gradlew fegenWeb</code> now, you will still see a warning by FeGen:</p>
<pre><code>[FeGen ProjectionMgr] The following entities do not have a base projection:
[FeGen ProjectionMgr] TodoItem
</code></pre>
<p>Base projections are needed for technical reasons.
They are interfaces that should be nested into the entity class that they belong to.
In our case, it would look like this:</p>
<pre><code class="language-java">@Entity
public class TodoItem {
    // ...
    
    @Projection(name = &quot;baseProjection&quot;, types = {TodoItem.class})
    interface BaseProjection {
        long getId();
        String getText();
        boolean isDone();
    }
}
</code></pre>
<p>They need to meet the following criteria to be accepted by FeGen:</p>
<ul>
<li>Have a <code>@Projection</code> annotation with <code>&quot;baseProjection&quot;</code> as <code>name</code> and the corresponding entity class as only item in <code>types</code></li>
<li>Have a method defined for each property of the corresponding entity whose type is not an entity or projection
<ul>
<li>The return type of the method must match the type of the corresponding property</li>
<li>The name of the method must be the name of the getter of the property, even if no getter exists on the entity</li>
</ul>
</li>
</ul>
<blockquote>
<p>This guide does not handle using other entities or projections as entities' fields as mentioned in the second bullet point.
To learn about it, go to the <a href="quickstart/../reference/data_model/relationships.html">Relationships</a> page of the reference documentation</p>
</blockquote>
<p>Your complete entity should look like this now and FeGen should not complain about it anymore:</p>
<pre><code class="language-java">package com.example.backend;

import org.springframework.data.rest.core.config.Projection;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;

@Entity
public class TodoItem {

    @Id
    @GeneratedValue
    public long id;

    @Column(nullable = false)
    public String text;

    public boolean done;

    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    public String getText() {
        return text;
    }

    public void setText(String text) {
        this.text = text;
    }

    public boolean isDone() {
        return done;
    }

    public void setDone(boolean done) {
        this.done = done;
    }

    @Projection(name = &quot;baseProjection&quot;, types = {TodoItem.class})
    interface BaseProjection {
        long getId();
        String getText();
        boolean isDone();
    }
}
</code></pre>
<h2 id="repository"><a class="header" href="#repository">Repository</a></h2>
<p>Although FeGen is happy with your entity, it still won't generate any code to access it.
That is because you have not yet defined a repository for it, so Spring will not offer you any way to interact with your entity from your frontend.
To change that, create an interface in the same directory as your <code>TodoItem</code> entity, name it <code>TodoItemRepository</code> and have it extend <code>JpaRepository&lt;TodoItem, Long&gt;</code>:</p>
<pre><code class="language-java">package com.example.backend;

import org.springframework.data.jpa.repository.JpaRepository;

public interface TodoItemRepository extends JpaRepository&lt;TodoItem, Long&gt; {}
</code></pre>
<p>Now FeGen will output the Typescript code necessary to access your <code>TodoItem</code> entity.</p>
<h2 id="cors"><a class="header" href="#cors">CORS</a></h2>
<p>In this guide, your backend will run on port <code>8080</code>, since this is spring's default port, and your frontend will use port <code>5000</code> which is the default port of the Rollup development server.
Without any further configuration, your browser will prevent your frontend from accessing the backend's API, because it will enforce the rules for Cross Origin Resource Sharing.
You will have to configure your backend to explicitly allow access from your frontend.
Create a class named <code>Config</code>, place it in the same directory as the other classes you created and enter the following content:</p>
<pre><code class="language-java">package com.example.backend;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.rest.core.config.RepositoryRestConfiguration;
import org.springframework.data.rest.webmvc.config.RepositoryRestConfigurer;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class Config {

    @Bean
    public WebMvcConfigurer webMvcConfigurer() {
        return new WebMvcConfigurer() {
            @Override
            public void addCorsMappings(CorsRegistry registry) {
                configureCors(registry);
            }
        };
    }

    @Bean
    public RepositoryRestConfigurer repositoryRestConfigurer() {
        return new RepositoryRestConfigurer() {
            @Override
            public void configureRepositoryRestConfiguration(RepositoryRestConfiguration config, CorsRegistry cors) {
                configureCors(cors);
            }
        };
    }

    private void configureCors(CorsRegistry registry) {
        registry.addMapping(&quot;/**&quot;)
                .allowedOrigins(&quot;http://localhost:5000&quot;)
                .allowedMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;);
    }
}
</code></pre>
<p>The two methods returning Configurers will ensure that each response to a request from your frontend will include an HTTP header that declares that this access is allowed.
The second method is important for us as it includes that header when calling repository endpoints to access entities.
The first method is not strictly necessary right now, but will add the header if you create and use custom endpoints.</p>
<p>This is all you have to do for the backend.
Go to the next page to learn how to use the code generated by FeGen in the frontend to finish your web app.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-the-frontend-1"><a class="header" href="#creating-the-frontend-1">Creating the Frontend</a></h1>
<p>On this page you will create the website that will display the actual todo list and access the backend using FeGen to store the todo list items.</p>
<h2 id="instantiate-the-api-client"><a class="header" href="#instantiate-the-api-client">Instantiate the API client</a></h2>
<p>If you have not yet done it after the last step, run <code>./gradlew fegenWeb</code> in the <code>backend</code> directory.
You should see generated files in the <code>frontend/src/api-client</code> directory.</p>
<p>The code generated by FeGen does not know under which URL the backend can be found, so you will need to pass that information when instantiating the api client.</p>
<p>Replace the content of <code>frontend/src/main.ts</code> with the following:</p>
<pre><code class="language-typescript">import {ApiClient} from &quot;./api-client/ApiClient&quot;;

const apiClient = new ApiClient(new FetchAdapter(&quot;http://localhost:8080&quot;));
</code></pre>
<p>The second line creates a new instance of <code>ApiClient</code>, which is generated by FeGen and takes an instance of <code>FetchAdapter</code> which controls how HTTP communication is done by the generated code.
It takes the base URL (the URL where the client expects find the backend) as first parameter.
Since you will run the backend on the same machine for now and Spring applications by default run on port <code>8080</code> and do not offer HTTPS, the base URL is <code>http://localhost:8080</code> in this case.</p>
<blockquote>
<p>In a production environment, you will need to change that base url.
Depending on your use case, you may want to use the same web server to deliver your frontend and handle your backend api calls.
In that case, it is a good idea to set a base path in Spring that the paths of all your API URLs start with.
If you use some kind of reverse proxy, you will also need to configure Spring to correctly recognize under what domain it is running.
To learn how to do this, refer to the <a href="quickstart/../reference/plugin_configuration/backend.html">Backend Configuration</a> page of the reference documentation.</p>
</blockquote>
<h2 id="displaying-the-empty-list-of-todos"><a class="header" href="#displaying-the-empty-list-of-todos">Displaying the (empty) List of Todos</a></h2>
<p>To show the todo items when opening the web app, append the following code to your <code>frontend/src/main.ts</code>:</p>
<pre><code class="language-typescript">/**
 * Create an HTML element representing the given todoItem
 */
const createTodoElement = (todoItem: TodoItem): HTMLElement =&gt; {
    const todoEl = document.createElement(&quot;div&quot;);

    const doneEl = document.createElement(&quot;input&quot;);
    doneEl.type = &quot;checkbox&quot;;
    doneEl.checked = todoItem.done;
    todoEl.appendChild(doneEl);

    const textEl = document.createElement(&quot;span&quot;);
    textEl.textContent = todoItem.text;
    todoEl.appendChild(textEl);
    
    return todoEl;
}

const loadTodoItems = () =&gt; {
    // Get the &lt;div&gt; element that will contain the items
    const listEl = document.querySelector(&quot;#todoItems&quot;)!;
    // Remove old items if there have been any
    listEl.innerHTML = &quot;&quot;;
    apiClient.todoItemClient.readAll().then(todoItems =&gt; {
        for (const todoItem of todoItems.items) {
            const itemEl = createTodoElement(todoItem);
            listEl.appendChild(itemEl);
        }
    }).catch(err =&gt; {
        console.error(&quot;Failed to fetch todo items&quot;, err);
        alert(&quot;Failed to fetch todo items&quot;)
    });
};
</code></pre>
<p>The line starting with <code>apiClient</code> refers to the variable you created in the previous step.
It contains an instance of a class generated by FeGen.
That class has a member called <code>todoItemClient</code> that contains method for basic CRUD functionality for the TodoItem entity like reading all instances of that entity.
FeGen will create such a member for each Entity / Repository combination you define.</p>
<p>The <code>readAll</code> method returns all todo item entity that currently exist in the backend.
It does not return them as a plain array though, but as a <code>Promise</code>, so the execution of frontend code is not interrupted while the browser is waiting for the backend to respond.
Using the <code>then</code> method of that <code>Promise</code>, we can specify what to do with the todo items once they are successfully retrieved from the backend.
The <code>todoItems</code> parameter is correctly typed using a type generated by FeGen, so you can enjoy autocompletion while iterating through the contained <code>items</code> array and accessing the <code>text</code> property that you have defined for that entity in the backend.
In case something goes wrong while retrieving the todo items (for example, if the backend server cannot be reached) the callback passed to the <code>catch</code> block is called, and you will see a dialog box.</p>
<blockquote>
<p>The method <code>readAll</code> actually does not return all elements by default, but only up to 20.
To learn how to configure this behaviour, refer to the <a href="quickstart/../reference/retrieving/paging_sorting.html">Paging and Sorting</a> page of the reference documentation</p>
</blockquote>
<blockquote>
<p>There are various ways besides a simple call to <code>readAll</code> to retrieve entities from the backend.
For example, you can pass sorting and paging parameters to <code>readAll</code> to only retrieve a sublist of a certain length in a specific order.
You can also create projections in the backend which specify a set of fields to return, which enables you to query related entities in one step.
With repository and custom searches you are able to filter the entities that are returned by the backend.
To learn how you can use these options with FeGen, refer to the <a href="quickstart/../reference/retrieving/intro.html">Retrieving Data</a> page of the reference documentation</p>
</blockquote>
<p>To actually run the code, you need to call the function that contains it, so append the following line at the bottom of <code>main.ts</code>:</p>
<pre><code class="language-typescript">const onReady = () =&gt; {
    loadTodoItems();
};

if (document.readyState !== 'loading') {
    // HTML is already completely initialized
    onReady();
} else {
    // Wait until initialization has completed
    document.addEventListener('DOMContentLoaded', onReady);
}
</code></pre>
<p>You can start the web app by running <code>./gradlew bootRun</code> in the <code>backend</code> directory and at the same time running <code>npm run dev</code> in the <code>frontend</code> directory.
However, if you open <code>http://localhost:5000/</code> in your browser, you will only see the headline, because there aren't any todo items yet.</p>
<h2 id="adding-todo-items"><a class="header" href="#adding-todo-items">Adding Todo Items</a></h2>
<p>To add todo items, we first need an input field to enter the new item's text and a button to trigger the creation.
Add the following HTML just below the <code>&lt;h1&gt;Todo App&lt;/h1&gt;</code> tag:</p>
<pre><code class="language-html">&lt;div&gt;
  &lt;label&gt;
    New Todo:
    &lt;input id=&quot;newTodoText&quot; type=&quot;text&quot; /&gt;
  &lt;/label&gt;
  &lt;button id=&quot;newTodoButton&quot;&gt;Create&lt;/button&gt;
&lt;/div&gt;
</code></pre>
<p>Now we still need to give that button some functionality.
Add the following code between the <code>loadTodoItems</code> and the <code>onReady</code> function:</p>
<pre><code class="language-typescript">const createTodo = async () =&gt; {
    const text = document.querySelector&lt;HTMLInputElement&gt;(&quot;#newTodoText&quot;).value;
    await apiClient.todoItemClient.create({
        text,
        done: false
    });
    // Use async function and await create result to avoid loading items before creation has finished
    loadTodoItems();
};
</code></pre>
<p>This will read the text out of the input element and use the code generated by FeGen to create a new instance of the todo item entity with that text in the backend.
After it waits for that operation to complete, it loads the todo items from the server again and updates the list.</p>
<blockquote>
<p>If you are developing a real application, you should probably wrap the call to <code>create</code> together with the <code>await</code> in a try block and let the user know if an error occurred in the corresponding <code>catch</code> block.
That is the async function equivalent to the error handling you did with <code>catch</code> when fetching all todo items.</p>
</blockquote>
<p>To run this code whenever the <code>Create</code> button is clicked, add the following line at the end of the <code>onReady</code> function body:</p>
<pre><code class="language-typescript">document.querySelector&lt;HTMLButtonElement&gt;(&quot;#newTodoButton&quot;).onclick = createTodo;
</code></pre>
<p>If you left <code>./gradlew bootRun</code> and <code>npm run dev</code> running, you will now be able to add todo items by entering a text and pressing <code>Create</code> after reloading the page once.
The todo items' texts should then appear below.
Try to reload the page or close and open the browser, and you will see that the todo items appear again because they are persisted in the backend.</p>
<blockquote>
<p>If you stop and restart the backend, the todo items will be lost, since you are currently only using the h2 in-memory database.
For applications used in a production environment, you should use a persistent database such as PostgreSQL.</p>
</blockquote>
<h2 id="modifying-todo-items"><a class="header" href="#modifying-todo-items">Modifying Todo Items</a></h2>
<p>You can already click the checkbox in front of each todo item to mark it as done, but that change will not be saved if you reload the application.
To make the changes persistent, add the following code between the lines <code>doneEl.checked = todoItem.done;</code> and <code>todoEl.appendChild(doneEl);</code> within the <code>createTodoElement</code> function's body:</p>
<pre><code class="language-typescript">doneEl.onchange = async () =&gt; {
  await apiClient.todoItemClient.update({
    ...todoItem,
    done: doneEl.checked
  });
  loadTodoItems();
};
</code></pre>
<p>Now each time the checkbox is clicked, the frontend will propagate the change to the backend, so you can reload the web app and still see which todos are done.</p>
<blockquote>
<p>Keep in mind that the <code>todoItem</code> variable does not only contain the <code>text</code> and <code>done</code> fields, but also the <code>id</code> field which is necessary for Spring to find the correct entity to modify.
This is why just replacing <code>...todoItem</code> by <code>text: todoItem.text</code> won't work.</p>
</blockquote>
<h2 id="deleting-todo-items"><a class="header" href="#deleting-todo-items">Deleting Todo Items</a></h2>
<p>Now that we can create todo items and mark them as done, there should also be a way to get rid of them.
Add the following code just above the <code>return todoEl</code> within the <code>createTodoElement</code> function's body:</p>
<pre><code class="language-typescript">const deleteButtonEl = document.createElement(&quot;button&quot;);
deleteButtonEl.textContent = &quot;X&quot;;
deleteButtonEl.onclick = async () =&gt; {
    await apiClient.todoItemClient.delete(todoItem);
    loadTodoItems();
};
todoEl.appendChild(deleteButtonEl);
</code></pre>
<p>The items in the list will now not only consist of a text, but also a button to delete the todo item.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="congratulations"><a class="header" href="#congratulations">Congratulations</a></h1>
<p>You completed the FeGen quick start guide.
You should now know have a basic understanding about what FeGen does and how you can use it to write a web app.
However, FeGen has a lot more to offer than what was included in the quick start guide.
Go to the next page to learn more.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reference-documentation"><a class="header" href="#reference-documentation">Reference Documentation</a></h1>
<p>The following pages contain detailed information about how FeGen can be used to generate type safe code to access Spring Data REST APIs.</p>
<h2 id="a-hrefreferenceplugin_configurationintrohtmlplugin-configurationa"><a class="header" href="#a-hrefreferenceplugin_configurationintrohtmlplugin-configurationa"><a href="reference/./plugin_configuration/intro.html">Plugin Configuration</a></a></h2>
<p>This section explains how to set up the FeGen plugin in your backend Spring project.
This includes all available configuration options for FeGen Typescript and FeGen Kotlin as well as instruction on how to include FeGen in a Gradle or Maven build.</p>
<h2 id="a-hrefreferencedata_modelintrohtmldata-modela"><a class="header" href="#a-hrefreferencedata_modelintrohtmldata-modela"><a href="reference/./data_model/intro.html">Data Model</a></a></h2>
<p>The data model section explains how you can use FeGen to make entities and custom endpoints available to your frontend.
It goes into detail about how entities can reference each other, how you can create custom controllers whose endpoints will be callable using FeGen's generated code and how you can exclude certain parts of your backend from FeGen code generation.</p>
<h2 id="a-hrefreferenceretrievingintrohtmlretrieving-dataa"><a class="header" href="#a-hrefreferenceretrievingintrohtmlretrieving-dataa"><a href="reference/./retrieving/intro.html">Retrieving Data</a></a></h2>
<p>This section is about how you can add projections as well as repository and custom searches to gain a more fine-grained control over what entities are returned to your client and which of their properties are included.
It also explains how you can use the built-in capabilities for paging and sorting.</p>
<h2 id="a-hrefreferencetargetsintrohtmltargetsa"><a class="header" href="#a-hrefreferencetargetsintrohtmltargetsa"><a href="reference/./targets/intro.html">Targets</a></a></h2>
<p>The targets section given an overview over the targets that FeGen currently supports.
It explains the differences between generating a Typescript client and generating one in Kotlin for Android or service to service communication.</p>
<h2 id="a-hrefreferencesecurityhtmlsecuritya"><a class="header" href="#a-hrefreferencesecurityhtmlsecuritya"><a href="reference/./security.html">Security</a></a></h2>
<p>In this section the features of FeGen Security will be explained.
With FeGen Security, you can check the kind of permissions you currently have to access or modify a certain entity or to call a certain endpoint or search.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="plugin-configuration"><a class="header" href="#plugin-configuration">Plugin Configuration</a></h1>
<p>This section explains how to set up the FeGen plugin in your backend Spring project.
This includes all available configuration options for FeGen Typescript and FeGen Kotlin as well as instruction on how to include FeGen in a Gradle or Maven build.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gradle"><a class="header" href="#gradle">Gradle</a></h1>
<p>The first step to use FeGen is to include the FeGen plugins for either Typescript, Kotlin or both in your build file.
If you are using gradle, you need to add a dependency in the <code>buildscript</code> within your <code>build.gradle</code>.
Make sure you have <code>mavenCentral()</code> set as one of your <code>buildscript</code> repositories.
You will need gradle version <code>6.0.1</code> or later for the plugin to work.</p>
<pre><code>buildscript {
    repositories {
        ...
        mavenCentral()
    }
    dependencies {
        ...
        classpath(&quot;com.github.materna-se.fegen:fegen-web-gradle-plugin:1.0-RC9&quot;) // For Typescript
        classpath(&quot;com.github.materna-se.fegen:fegen-kotlin-gradle-plugin:1.0-RC9&quot;) // For Kotlin
    }
}
</code></pre>
<p>Then you need to apply the plugin(s) to your project.</p>
<pre><code>apply(plugin = &quot;de.materna.fegen.web&quot;)
apply(plugin = &quot;de.materna.fegen.kotlin&quot;)
</code></pre>
<p>Applying the plugin enables you to configure the FeGen plugins using the <code>fegenWeb</code> and <code>fegenKotlin</code> sections.</p>
<pre><code>configure&lt;de.materna.fegen.web.gradle.FeGenWebGradlePluginExtension&gt; {
    scanPkg = &quot;com.example.your.main.package&quot;
    frontendPath = &quot;../frontend/src/generated-client&quot;
}

configure&lt;de.materna.fegen.web.gradle.FeGenKotlinGradlePluginExtension&gt; {
    scanPkg = &quot;com.example.your.main.package&quot;
    frontendPath = &quot;../android-app/src/main/kotlin&quot;
    frontendPkg = &quot;com.example.your.main.package.api&quot;
}
</code></pre>
<blockquote>
<p>You can find all configuration options on the <a href="reference/plugin_configuration/./configuration_options.html">Configuration Options</a> page.</p>
</blockquote>
<p>If you want to use custom endpoints and are using a Spring version that ships with version 1.0.0 or later of <code>spring-hateoas</code>, you will need also need to add <code>fegen-spring-util</code> as a dependency.
This ensures that links required by FeGen will be added to the return values of custom endpoints.</p>
<pre><code>dependencies {
    ...
    implementation(&quot;com.github.materna-se.fegen:fegen-spring-util:1.0-RC9&quot;)
}
</code></pre>
<p>Once you are happy with your configuration, you can run the following command to have FeGen generate the client code in Typescript.</p>
<pre><code class="language-shell">./gradlew fegenWeb
</code></pre>
<p>To generate code in Kotlin, replace <code>fegenWeb</code> with <code>fegenKotlin</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="maven"><a class="header" href="#maven">Maven</a></h1>
<p>The first step to use FeGen is to include the FeGen plugins for either Typescript, Kotlin or both in your build file.
If you are using maven, add the following configuration to the <code>build/plugins</code> section of your <code>pom.xml</code> to generate a Typescript client using FeGen:</p>
<pre><code>&lt;plugin&gt;
    &lt;groupId&gt;com.github.materna-se.fegen&lt;/groupId&gt;
    &lt;artifactId&gt;fegen-web-maven-plugin&lt;/artifactId&gt;
    &lt;version&gt;1.0-RC9&lt;/version&gt;
    &lt;configuration&gt;
        &lt;scanPkg&gt;com.example.your.main.package&lt;/scanPkg&gt;
        &lt;frontendPath&gt;../frontend/src/generated-client&lt;/frontendPath&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;
</code></pre>
<p>If you want to generate Kotlin instead, use the following:</p>
<pre><code>&lt;plugin&gt;
    &lt;groupId&gt;com.github.materna-se.fegen&lt;/groupId&gt;
    &lt;artifactId&gt;fegen-kotlin-maven-plugin&lt;/artifactId&gt;
    &lt;version&gt;1.0-RC9&lt;/version&gt;
    &lt;configuration&gt;
        &lt;scanPkg&gt;com.example.your.main.package&lt;/scanPkg&gt;
        &lt;frontendPath&gt;../android-app/src/main/kotlin&lt;/frontendPath&gt;
        &lt;frontendPkg&gt;com.example.your.main.package.api&lt;/frontendPkg&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;
</code></pre>
<blockquote>
<p>You can find all configuration options on the <a href="reference/plugin_configuration/./configuration_options.html">Configuration Options</a> page.
Add them as XML elements next to <code>scanPkg</code> and <code>frontendPath</code>.</p>
</blockquote>
<p>You can also add both plugins to generate a web and an android or inter service client.</p>
<p>If you want to use custom endpoints and are using a Spring version that ships with version 1.0.0 or later of <code>spring-hateoas</code>, you will need also need to add <code>fegen-spring-util</code> as a dependency.
This ensures that links required by FeGen will be added to the return values of custom endpoints.</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;com.github.materna-se.fegen&lt;/groupId&gt;
    &lt;artifactId&gt;fegen-spring-util&lt;/artifactId&gt;
    &lt;version&gt;1.0-RC9&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration-options"><a class="header" href="#configuration-options">Configuration options</a></h1>
<p>The following configuration keys are mandatory:</p>
<table><thead><tr><th>Key</th><th>Description</th></tr></thead><tbody>
<tr><td><code>scanPkg</code></td><td>The package that contains all entities, projections, repositories and custom endpoints you want to generate frontend code for</td></tr>
<tr><td><code>frontendPath</code></td><td>The directory to which the generated (Typescript or Kotlin) files should be written. It must exist and should be specified relative to the <code>targetProject</code>. If you are generating Kotlin code, specify the source directory corresponding to the root package. It might be useful to create a sub project for each target language containing solely the generated code in case multiple applications should communicate with the backend.</td></tr>
</tbody></table>
<p>The following configuration keys are optional:</p>
<table><thead><tr><th>Key</th><th>Default value</th><th>Description</th></tr></thead><tbody>
<tr><td><code>targetProject</code></td><td>The project the fegen plugin is applied to</td><td>The project that contains the spring application for which frontend code should be generated</td></tr>
<tr><td><code>entityPkg</code></td><td>Same as <code>scanPkg</code></td><td>The package that contains all entities and projections you want to generate frontend code for</td></tr>
<tr><td><code>repositoryPkg</code></td><td>Same as <code>scanPkg</code></td><td>The package that contains all repositories and custom endpoints you want to generate frontend code for</td></tr>
<tr><td><code>datesAsString</code></td><td><code>false</code></td><td>Whether time data such as <code>java.time.LocalDateTime</code> should be transmitted as strings</td></tr>
<tr><td><code>implicitNullable</code></td><td><code>&quot;ERROR&quot;</code></td><td>How to treat fields of entities that are nullable, but not explicitly annotated with <code>@Nullable</code>. Possible values are <code>&quot;ERROR&quot;</code>, <code>&quot;WARN&quot;</code> and <code>&quot;ALLOW&quot;</code></td></tr>
</tbody></table>
<p>The following configuration keys are required when the output of FeGen is Kotlin code (meaning that the fegenKotlin plugin is used):</p>
<table><thead><tr><th>Key</th><th>Description</th></tr></thead><tbody>
<tr><td><code>frontendPkg</code></td><td>The package to which the frontend code should be generated</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="backend-configuration"><a class="header" href="#backend-configuration">Backend Configuration</a></h1>
<p>In addition to adding and configuring the FeGen plugin, you may need to change some options in your <code>application.properties</code> in order for FeGen to work.</p>
<h2 id="base-path"><a class="header" href="#base-path">Base Path</a></h2>
<p>If you use a development server provided by your frontend framework (such as React) it is convenient to enable the proxying of requests that the frontend cannot handle to your backend server.
In React this can be done by adding the following property to your <code>package.json</code>.</p>
<pre><code>&quot;proxy&quot;: &quot;http://localhost:8080&quot;
</code></pre>
<p>However, if you use this setup, you might run into two issues.</p>
<p>The first one arises from conflicts of endpoints that you use in your frontend as well as your backend.
For example, a GET request to <code>/users</code> may cause your frontend server to return an HTML page with a list of users, while your backend might return a JSON list of available users.
To avoid problems associated with URL clashes like that, you can specify a base path for your backend.</p>
<pre><code>spring.data.rest.base-path=api
</code></pre>
<h2 id="forward-headers-strategy"><a class="header" href="#forward-headers-strategy">Forward Headers Strategy</a></h2>
<p>The Spring server must know how it can be reached, because when it returns an entity, it also includes links to manipulate this entity and related entities in its response and FeGen relies on those links to be correct.
Some proxies (such as the development server used by React) will however not include the original host name in the HTTP request, but instead place it in a header like <code>X-Forwarded-Host</code>.</p>
<p><strong>Trusting those headers may however impose a security risk</strong>, as they can be added by malicious clients if do not implement measures to prevent that (See <a href="https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/spring-framework-reference/web.html#filters-forwarded-headers">this</a> section of the Spring documentation).
You can tell spring to trust those headers by adding the following to your <code>application.properties</code>.</p>
<pre><code class="language-properties">server.forward-headers-strategy=framework
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-model"><a class="header" href="#data-model">Data Model</a></h1>
<p>This section explains how you can use FeGen to make entities and custom endpoints available to your frontend.
It goes into detail about how entities can reference each other, how you can create custom controllers whose endpoints will be callable using FeGen's generated code and how you can exclude certain parts of your backend from FeGen code generation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="entities"><a class="header" href="#entities">Entities</a></h1>
<p>The basic building block of FeGen's and Spring's data model are entities.
Those are classes annotated with <code>javax.persistence.Entity</code> for which a database table will be created where instances of those classes can be stored together with their fields.
For an entity class to work with FeGen, it needs to meet the following criteria:</p>
<ul>
<li>They must be located in the package specified by <code>scanPkg</code>
<ul>
<li>or <code>entityPkg</code> if that configuration key exists, see <a href="reference/data_model/../plugin_configuration/configuration_options.html">Configuration Options</a></li>
</ul>
</li>
<li>They must have an <code>@Entity</code> annotation</li>
<li>They have an <code>id</code> field of type <code>long</code>
<ul>
<li>That field is annotated with <code>@Id</code> and <code>@GeneratedValue</code></li>
</ul>
</li>
<li>Other fields are annotated with a <code>@Column</code> annotation specifying <code>nullable</code> as true or false (even in Kotlin)
<ul>
<li><code>@Notnull</code> and <code>@Nullable</code> from Spring validation may be used instead</li>
</ul>
</li>
<li>They have a base projection</li>
</ul>
<p>The last one is important since there are certain scenarios in which entities returned by the backend will not have certain properties that are required by the code generated by FeGen.</p>
<h2 id="base-projection"><a class="header" href="#base-projection">Base projection</a></h2>
<p>A base projection is necessary for an entity to be correctly returned when using FeGen to request it in a client.
It is an interface definition that is nested within the entity class and meets the following criteria:</p>
<ul>
<li>It is annotated with <code>@Projection</code></li>
<li>The <code>name</code> property of its <code>@Projection</code> annotation must be <code>&quot;baseProjection&quot;</code></li>
<li>The <code>types</code> property of the annotation contains only the class of the entity for which the interface is a projection</li>
<li>It must include a getter for all fields whose types are not entities nor projections including the <code>id</code> field.</li>
</ul>
<h2 id="java"><a class="header" href="#java">Java</a></h2>
<p>An example entity in Java may look like this:</p>
<pre><code class="language-java">import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;

import org.springframework.data.rest.core.config.Projection;
import org.springframework.lang.Nullable;

@Entity
public class SomeEntity {

    @Id
    @GeneratedValue
    public long id;

    @Column(nullable = false)
    public String nonNullableField;

    @Nullable
    public String nullableField;

    private long value;

    public long getValue() {
        return value;
    }

    public void setValue(long value) {
        this.value = value;
    }

    private boolean b;

    public boolean isB() {
        return b;
    }

    public void setB(boolean b) {
        this.b = b;
    }

    @Projection(name = &quot;baseProjection&quot;, types = {SomeEntity.class})
    interface BaseProjection {
        long getId();
        String getNonNullableField();
        String getNullableField();
        long getValue();
        boolean isB();
    }
}
</code></pre>
<p>As you can see, there are two options of defining entity columns.
You can either just use a single field or specify a getter for your field (like it was done for the <code>value</code> and <code>b</code> columns).
Since Spring and FeGen can conclude from the name and signature of the function that <code>getValue</code> is a getter for <code>value</code>, only one column named <code>value</code> is created.
If you wanted to annotate the <code>value</code> or <code>b</code> column, you could do so on the getter or the field.</p>
<p>Since the <code>value</code> and <code>b</code> columns have primitive types, you do not need to specify their nullability.</p>
<h2 id="kotlin"><a class="header" href="#kotlin">Kotlin</a></h2>
<p>The entity from the Java example may look like this if written in Kotlin:</p>
<pre><code class="language-kotlin">import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import org.springframework.lang.Nullable;

@Entity
class SomeEntity {
    
    @Id
    @GeneratedValue
    var id: Long = -1

    @Column(nullable = false)
    lateinit var nonNullableField: String
    
    @Nullable
    var nullableField: String? = null
    
    var value: Long = 0
    
    var b: Boolean = false

    @Projection(name = &quot;baseProjection&quot;, types = [SomeEntity::class])
    interface BaseProjection {
        val id: Long
        val firstName: String
        val lastName: String
        val number: String?
    }
}
</code></pre>
<p>In Kotlin, it is best to define columns using the <code>var</code> keyword.
If the type of your column is primitive, you need to initialize it like it is the case with <code>id</code> and <code>value</code>.
Otherwise, you can use the <code>lateinit</code> modifier to avoid having to initialize a property that will often be overwritten by the contents of the database anyway.</p>
<p>You still have to specify nullability for non-primitive properties, even though Kotlin has a notion of nullability in its types, because Spring will ignore them.</p>
<p>For the base projection you can just use <code>val</code>s as they will be recognized by Spring in the same way as getters are.</p>
<h2 id="repositories"><a class="header" href="#repositories">Repositories</a></h2>
<p>Without a repository, you will not be able to perform CRUD operations on your entity from the code generated by FeGen.</p>
<p>The repository for your entity must be an interface that meets the following criteria:</p>
<ul>
<li>It is located in the package specified by <code>scanPkg</code>
<ul>
<li>or <code>repositoryPkg</code> if that configuration key exists, see <a href="reference/data_model/../plugin_configuration/configuration_options.html">Configuration Options</a></li>
</ul>
</li>
<li>It extends <code>JpaRepository</code> with your entity and <code>Long</code> as type parameters</li>
</ul>
<p>In Java, it will look like this:</p>
<pre><code class="language-java">public interface SomeEntityRepository extends JpaRepository&lt;SomeEntity, Long&gt; {}
</code></pre>
<p>In Kotlin, it will look like this:</p>
<pre><code class="language-kotlin">interface SomeEntityRepository: JpaRepository&lt;SomeEntity, Long&gt;
</code></pre>
<h2 id="frontend"><a class="header" href="#frontend">Frontend</a></h2>
<p>To see how you can access your entities from your frontend, take a look at the <a href="reference/data_model/../targets/typescript.html">Typescript</a> or <a href="reference/data_model/../targets/kotlin.html">Kotlin</a> page depending on what client language you are generating code for.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pojos"><a class="header" href="#pojos">POJOs</a></h1>
<p>POJO (also known as Plain Old Java Object) refers to simple Java object, which is not annotated with any specific annotation. POJO (or list of them ) can be used to define a custom response body or custom return value in controllers implementation. 
FeGen supports POJOs, which contain primitives as well as references to another POJOs.</p>
<p>The following example (Kotlin) shows how you can define your POJO class and integrate it into the code of custom controllers (definition of custom controllers is described at <a href="reference/data_model/custom_endpoints.html">Custom endpoints</a> page):</p>
<pre><code class="language-kotlin">class SomePojo(
	@NotNull var string: String,
	@Nullable var number: Double?,
	@Nullable var boolean: Boolean?
)

@RequestMapping(&quot;pojo&quot;, method = [RequestMethod.POST])
@ResponseBody
fun pojosEndpoint(@RequestBody body: SomePojo): ResponseEntity&lt;SomePojo&gt; {
	return ResponseEntity.ok(body)
}
</code></pre>
<p>In Kotlin, you may define a POJO using the syntax above. You can annotate the attributes with <code>@NotNull</code> and <code>@Nullable</code> as well. Then it can be used as a request body (annotated with <code>@RequestBody</code>) as well as a return value if you place it as a generic argument of <code>ResponseEntity</code>. FeGen recognizes lists of POJOs too.</p>
<p>POJOs can reference other POJOs or contain lists of them. In these cases FeGen generates type definitions for all types of POJOs including referenced ones. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="relationships"><a class="header" href="#relationships">Relationships</a></h1>
<p>Entities in your data model may reference each other.
For example, you might want to introduce a <code>User</code> entity to the todo list example from the quick start guide that looks like this:</p>
<pre><code class="language-java">@Entity
class User {
    
    @Id
    @GeneratedValue
    public long id;
    
    @Column(nullable = false)
    public String firstName;
    
    @Column(nullable = false)
    public String lastName;

    @Projection(name = &quot;baseProjection&quot;, types = {User.class})
    interface BaseProjection {
        long getId();
        String getFirstName();
        String getLastName();
    }
}
</code></pre>
<h2 id="backend"><a class="header" href="#backend">Backend</a></h2>
<p>Now you want to associate each <code>User</code> with a list of <code>TodoItem</code>s.
You can do this by adding the following attribute to the <code>TodoItem</code> entity class:</p>
<pre><code class="language-java">@ManyToOne(optional = false)
public User creator;
</code></pre>
<p>Take note that in this case, it is also required to specify whether the <code>User</code> is optionally associated with a <code>TodoItem</code>, so the <code>creator</code> property may be null, or not.
Also you must not add a corresponding getter (or <code>val</code> in case of Kotlin) to your base projection, since the base projection should only cover primitive properties.</p>
<p>Now each <code>TodoItem</code> is associated with one <code>User</code> that you can access in the Typescript frontend as follows (the Kotlin frontend works analogous):</p>
<p>If you want to go the other way around and access all <code>TodoItem</code>s that belong to a certain <code>User</code>, you have to add the corresponding property to the <code>User</code> class:</p>
<pre><code class="language-java">@OneToMany(mappedBy = &quot;creator&quot;)
public List&lt;TodoItem&gt; todos;
</code></pre>
<p>In this case you do not need to specify nullability because <code>@OneToMany</code> and <code>@ManyToMany</code> relationships will never be nullable since they may just contain an empty list.</p>
<p>Accessing the <code>TodoItems</code> for a <code>User</code> works analogous to the reverse access discussed before, but the call to <code>readTodos</code> will of course return a promise with an array of values.</p>
<p>If you specify your entities this way, a single <code>TodoItem</code> may belong to only a single <code>User</code>.
FeGen also supports the use of <code>@ManyToMany</code> relationships on both sides to lift this restriction.
In the frontend, accessing related items works the same as with <code>@OneToMany</code> relationships.</p>
<p>If you wanted to add a associate an address entity with each user, and each address may only belong to one user, you can use a <code>@OneToOne</code> relationship on both sides, which is also supported by FeGen and works like the <code>@ManyToOne</code> relationship in the frontend.</p>
<h2 id="frontend-1"><a class="header" href="#frontend-1">Frontend</a></h2>
<p>To access related entities in the generated code, you have two options.</p>
<p>The first one is to use projections which enable you to fetch an entity and a whole set of (even transitively) related entities in one api call.
To see how they work, refer to the page <a href="reference/data_model/../retrieving/projections.html">Projections</a>.</p>
<p>The other one is using the methods that are generated into the API clients of the entities that contain the relationships.</p>
<p>For example, if you added the <code>creator</code> property to your <code>TodoItem</code> entity, you can now use the <code>readCreator</code> method to retrieve <code>User</code>s associated with a specific <code>TodoItem</code>.</p>
<pre><code class="language-typescript">const todoItems: TodoItem[] = (await apiClient.todoItemClient.readAll()).items;
const todoItem = todoItems[27];
const user: User = await apiClient.todoItemClient.readCreator(todoItem);
</code></pre>
<p>Such a <code>read</code> method is generated for all relationships mentioned earlier, although <code>@OneToMany</code> and <code>@ManytoMany</code> relationships will of course return an array instead of a single value.
The corresponding Kotlin code is analogous.</p>
<p>You can use the following methods to add or remove relationships between entities.
It is important that all the objects passed to such a set method have already been created in the backend.
Conversely, the <code>todosToDelete</code> object will not be deleted from the database.</p>
<pre><code class="language-typescript">apiClient.userClient.setTodos(user, todos);
apiClient.userClient.deleteFromTodos(user, todosToDelete);
</code></pre>
<p>If your relationship is <code>@OneToMany</code> or <code>@ManyToMany</code>, you can use the following method to add a single object to the relationship without removing the others.</p>
<pre><code class="language-typescript">apiClient.userClient.addToTodos(room, todoToAdd);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-endpoints"><a class="header" href="#custom-endpoints">Custom endpoints</a></h1>
<p>Custom endpoints are methods inside a controller class that may look as follows.</p>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/api/todoItems&quot;)
public class CustomEndpointController {

    // ...
}
</code></pre>
<p>If you are using Kotlin, you should add the <code>open</code> modifier to the class declaration.</p>
<p>For a controller to be recognized as a container for custom endpoints, it needs to fulfill the following criteria:</p>
<ul>
<li>It must have a <code>@RestController</code> and a <code>@RequestMapping</code> annotation</li>
</ul>
<p>Take note that the <code>spring.data.rest.base-path</code> you specified in <code>application.properties</code> will not be applied to the <code>@RequestMapping</code> unless you also add the annotation <code>@BasePathAwareController</code>.</p>
<p>You can then specify custom endpoints in such classes where parameters are annotated with <code>@RequestParam</code>, <code>@PathVariable</code> or <code>@RequestBody</code>.</p>
<pre><code class="language-kotlin">@RequestMapping(&quot;createOrUpdate&quot;, method = [RequestMethod.POST])
open fun createOrUpdateContact(
        @RequestParam firstName: String,
        @RequestParam lastName: String
): ResponseEntity&lt;EntityModel&lt;User&gt;&gt; {
    // ...
}
</code></pre>
<p>FeGen will generate a method in the API client corresponding to the <code>path</code> or value in <code>@RequestMapping</code> if the backend method has a <code>@RequestMapping</code> (or <code>@GetMapping</code>, <code>@PostMapping</code>, etc.) annotation.</p>
<p>Custom endpoints must have a void return type or return entities.
In the latter case, the entity class must be wrapped in an <code>EntityModel</code> (if a single entity should be returned) or in <code>CollectionModel</code> or <code>PagedModel</code> (if multiple entities should be returned).
Those classes themselves must be wrapped in a <code>ResponseEntity</code>.</p>
<p>Custom endpoints can also return pojos. In this case, a pojo or a list of those must be wrapped in a <code>ResponseEntity</code>.
They may also respond with primitive values in the same way.
Returning <code>String</code> is however not supported, since they will not be converted to a JSON string.
Instead, return a <code>TextNode</code> wrapped in a <code>ReponseEntity</code>.</p>
<p>To reliably use the returned values in the frontend, make sure you added the <code>fegen-spring-util</code> dependency to your Spring project.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="embeddables"><a class="header" href="#embeddables">Embeddables</a></h1>
<p>Sometimes, you need a certain set of attributes in multiple entities.
An example for this could be longitude and latitude which should be two fields that every entity should have if a physical location can be associated with it.</p>
<p>Spring supports this by letting you define classes and mark them as embeddable:</p>
<pre><code class="language-java">@Embeddable
class Coordinates {

    public long longitude;
    
    public long latitude;
}
</code></pre>
<p>You can then add those attributes to an entity by adding a corresponding field and annotating it with <code>@Embedded</code>:</p>
<pre><code class="language-java">@Entity
public class City {
    
    // ...
    
    @Embedded
    private Coordinates location;

    @Projection(name = &quot;baseProjection&quot;, types = {City::class})
    interface BaseProjection {
        // ...
        Coordinates getLocation();
    }
}
</code></pre>
<p>Take note that you also need to add <code>@Embedded</code> fields to your base projection.
FeGen will generate a <code>location</code> field in the <code>City</code> type that will contain the two fields <code>longitude</code> and <code>latitude</code>.</p>
<p>At the time of writing, FeGen only supports primitive fields in <code>@Embeddable</code> classes.
This means that using types other than boolean, numbers and strings (like entities) won't work.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fegenignore"><a class="header" href="#fegenignore">@FegenIgnore</a></h1>
<p>Sometimes you might want to exclude a <a href="reference/data_model/./custom_endpoints.html">custom endpoint</a> or a <a href="reference/data_model/../retrieving/repository_searches.html">repository</a> or <a href="reference/data_model/../retrieving/custom_searches.html">custom search</a> from FeGen code generation, so FeGen will ignore the respective endpoint.
One of those use cases could be that it uses a feature like file up- or download that FeGen does not currently support.</p>
<p>You can do that by using the annotation <code>@FegenIgnore</code> from the <code>fegen-spring-util</code> library.
Apply it to a controller class for FeGen to not generate any custom search or custom endpoint code for it or apply it to just one method for FeGen to only ignore that method.</p>
<p>If you annotate an interface that defines a repository, all methods inside that repository will be ignored, so no repository search client code will be generated.
You can also annotate single methods within the repository for that purpose.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="retrieving-data"><a class="header" href="#retrieving-data">Retrieving Data</a></h1>
<p>This section is about how you can add projections as well as repository and custom searches to gain a more fine-grained control over what entities are returned to your client and which of their properties are included.
It also explains how you can use the built-in capabilities for paging and sorting.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="paging-and-sorting"><a class="header" href="#paging-and-sorting">Paging and sorting</a></h1>
<h2 id="paging"><a class="header" href="#paging">Paging</a></h2>
<p>When reading the quick start guide, you may have asked yourself why the <code>readAll</code> method of the generated client did not just return an array of <code>TodoItem</code>s, but an object where the actual <code>TodoItem</code> were in a field called <code>items</code>.
This is because <code>readAll</code> supports paging and also returns paging metadata.
Next to the <code>items</code> field, you can also access an object of the following type:</p>
<pre><code class="language-typescript">interface PageData {
    size: number; // The size of the current page
    totalElements: number; // How many entities there are in total
    totalPages: number; // How many pages you can query (So totalElements / size, rounded up)
    number: number; // The page for which items have been returned, starting at 0
}
</code></pre>
<p>The corresponding Kotlin data class has the same fields and can be accessed in the same way.
If you inspect the response you get when loading the <code>TodoItem</code>s in the quick start guide example, you will notice that by default, a maximum of <code>20</code> entities will be retrieved.</p>
<p>If you have more than 20 entities, you can pass an integer as the first parameter.
Take note that this number is an index starting at <code>0</code>, so if you wish to retrieve items <code>21</code> up to <code>40</code>, you have to use <code>1</code> as the parameter.
If you do not specify the first parameter or use <code>undefined</code>, the default page will be <code>0</code>.</p>
<p>You are not restricted to pages of size <code>0</code>, but you can use the second parameter to pass the page size.</p>
<h2 id="sorting"><a class="header" href="#sorting">Sorting</a></h2>
<p>The third parameter of <code>readAll</code> is used for returning entities in a specific order.
A corresponding call may look like this:</p>
<pre><code class="language-typescript">const comments = await apiClient.commentClient.readAll(undefined, undefined, &quot;createdAt,DESC&quot;);
</code></pre>
<p>In this example, a list of comments is retrieved so that the most recent comment is the first one in the list.
Only the <code>20</code> most recent comments are returned, since the default values for <code>page</code> and <code>size</code> are <code>0</code> and <code>20</code> respectively.
The <code>sort</code> parameter must be string consisting of a property to sort by and a sort direction of either <code>ASC</code> (ascending) or <code>DESC</code> (descending) separated by a comma.</p>
<h2 id="other-methods"><a class="header" href="#other-methods">Other methods</a></h2>
<p>Paging and sorting is neither restricted to Typescript nor to the <code>readAll</code> method.
You can use both when fetching <a href="reference/retrieving/./projections.html">projections</a> and <a href="reference/retrieving/./repository_searches.html">repository searches</a>.
For <a href="reference/retrieving/./custom_searches.html">custom searches</a>, at least sorting is currently available.
Of course the parameters mentioned here do not only exist in Typescript, but also in Kotlin code generated by FeGen.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="projections"><a class="header" href="#projections">Projections</a></h1>
<p>You already got to know a specific kind of projection in the quick start guide: the base projection.
While that one has no further benefits but to make your FeGen client work in the first place, projections in general can be used to fetch related data from different entities at once.</p>
<p>Generally speaking, a projection is an interface that satisfies the following criteria.</p>
<ul>
<li>It is located in the package specified by <code>entityPkg</code></li>
<li>It is annotated with <code>@Projection</code>
<ul>
<li>The <code>types</code> property of the annotation contains the class of the entity for which the interface is a projection</li>
</ul>
</li>
<li>It contains a getter for a subset of the fields declared in the entity (In Kotlin, a <code>val</code> field is sufficient)
<ul>
<li>If the type an entity field is another entity, the type of the getter in the projection must be a projection of the other entity</li>
</ul>
</li>
</ul>
<p>The last bullet point sets projections in general apart from base projections, which must not include any fields containing related entities.</p>
<p>You can use projections to include fields that contain related entities.
Assume you have a <code>User</code> entity that has a field <code>address</code> annotated with <code>@OneToOne</code> containing an <code>Address</code> entity.
You can then create the following projection.</p>
<pre><code class="language-java">@Projection(name = &quot;withAddress&quot;, types = {User.class})
interface UserWithAddress {
    long getId();
    // ... other fields like first and last name
    Address.BaseProjection getAddress();
}
</code></pre>
<p>It is important to not return entity classes in projection's getters, but other projections.
Otherwise, issues can arise in the frontend that are caused by link properties missing from certain objects returned by the REST API.</p>
<p>In the frontend, methods corresponding to your projection will be generated in the entity's client that allow you to retrieve all or a single object based on your entity with the fields specified in your projection.
FeGen will also generate an interface for all projections you specify.</p>
<pre><code class="language-typescript">const users: UserWithAddress[] = (await apiClient.userClient.readProjectionsUserWithAddress()).items;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="repository-searches"><a class="header" href="#repository-searches">Repository Searches</a></h1>
<p>While projections give you fine-grained control over which attributes of an entity are returned, repository searches allow you to filter which entities are returned in the first place.</p>
<p>Spring enables you to create endpoints for searches by specifying methods in a repository interface.
They can either have a query annotation specifying their return value or have their semantics implied by their name.</p>
<pre><code class="language-java">@RepositoryRestResource
interface ContactRepository extends JpaRepository&lt;Contact, Long&gt; {
    
    @Query(&quot;SELECT u FROM User u WHERE u.firstName LIKE CONCAT('%', :name, '%') OR u.lastName LIKE CONCAT('%', :name, '%')&quot;)
    Page&lt;Contact&gt; findByNameContaining(
        @RequestParam @Param(&quot;name&quot;) String name,
        Pageable pageable
    );
}
</code></pre>
<p>To use such a search method in your frontend, it has to satisfy certain criteria:</p>
<ul>
<li>It must be defined in a repository meeting the criteria specified in the Basic Usage section</li>
<li>Its name must start with <code>find</code></li>
<li>It must <em>not</em> have a <code>@RestResource</code> annotation where <code>exported</code> is set to <code>false</code></li>
</ul>
<p>Your repository search may either return an entity, a <code>List</code> of entities, or a <code>Page</code> of entities.
The latter will enable you to retrieve only a subset of the returned entities by specifying a page and a page size in the frontend.
You will need to add a <code>Pageable</code> parameter to your method for this to work.</p>
<p>In your frontend code, a corresponding method will be generated in the client belonging to the repository that contains the search method.</p>
<pre><code class="language-typescript">apiClient.userClient.searchFindByNameContaining(&quot;name_part&quot;);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-searches"><a class="header" href="#custom-searches">Custom Searches</a></h1>
<p>Custom searches are similar to repository searches, but reside in their own controller.
Instead of specifying queries, you are able to write Java or Kotlin code to calculate their response.</p>
<p>You first need to create a controller class that will contain your search methods.
There are no restrictions on how many of those controllers may exist.</p>
<pre><code class="language-java">@BasePathAwareController
@RequestMapping(path = { &quot;/search&quot; })
class SearchController {
    // ...
}
</code></pre>
<p>The controller class must meet the following requirements in order for FeGen to detect it:</p>
<ul>
<li>It has a <code>@BasePathAwareController</code> annotation</li>
<li>It has a <code>@RequestMapping</code> annotation whose value or <code>path</code> ends with <code>/search</code></li>
</ul>
<p>Then you can then add search methods to your controller:</p>
<pre><code class="language-java">@BasePathAwareController
@RequestMapping(path = { &quot;/search&quot; })
class SearchController {
    
    @RequestMapping(&quot;usersByRegex&quot;)
    public ResponseEntity&lt;CollectionModel&lt;EntityModel&lt;User.BaseProjection&gt;&gt;&gt; usersByRegex(
            @RequestParam(name = &quot;nameRegex&quot;) String name
    ) {
        // ...
        return ResponseEntity.ok(CollectionModel.wrap(userList));
    }
}

</code></pre>
<p>Those methods must adhere to the following rules to work with FeGen:</p>
<ul>
<li>They have a <code>@RequestMapping</code> annotation</li>
<li>Their parameters must have a <code>@RequestParam</code> annotation (request body or path variables are not supported yet)</li>
<li>They have a return type of the form <code>ResponseEntity&lt;CollectionModel&lt;EntityModel&lt;P&gt;&gt;&gt;</code> where <code>P</code> is a projection</li>
</ul>
<p>Using a custom search in the frontend works the same as with repository searches.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="targets"><a class="header" href="#targets">Targets</a></h1>
<p>This section given an overview over the targets that FeGen currently supports.
It explains the differences between generating a Typescript client and generating one in Kotlin for Android or service to service communication.</p>
<p>You also learn how to create separate projects for your generated API code.
Although FeGen allows you to directly generate code into your frontend projects as you saw in the quick start guide, creating separate projects for the generated code allows you to share it between multiple frontends.</p>
<p>If you generate code in different target languages but for the same Spring application, it will be very similar.
That is why only the setup, and the basic CRUD functionality is explained in this section for each target.
If you want to know how you can use it with other features such as projections or relationships, refer to the corresponding section.
The code there will only be in Typescript, however, Kotlin code is very similar.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript"><a class="header" href="#typescript">Typescript</a></h1>
<p>The typescript target is allows you to use your Spring API in the browser.</p>
<h2 id="standalone-api-project"><a class="header" href="#standalone-api-project">Standalone API project</a></h2>
<p>If you want to share the generated typescript code to access your Spring API, you should generate a separate NPM project for it, so execute the following command in a new directory and follow the instructions:</p>
<pre><code class="language-shell">npm init
</code></pre>
<p>Your API project will also need to have a development dependency to Typescript in order to transpile it to javascript as well as a normal dependency to the FeGen runtime which will be used by the generated code:</p>
<pre><code class="language-shell">npm install --save-dev typescript
npm install @materna-se/fegen-runtime
</code></pre>
<p>To build the project, you also need to generate a Typescript configuration file.
Install Typescript globally if you haven't already:</p>
<pre><code class="language-shell">npm install -g typescript
</code></pre>
<p>Then initialize the configuration in your API project:</p>
<pre><code class="language-shell">tsc --init
</code></pre>
<p>You can then further configure Typescript, for example by setting <code>./dist</code> as the output directory:</p>
<pre><code class="language-json">{
  &quot;compilerOptions&quot;: {
    // ...
    &quot;outDir&quot;: &quot;./dist&quot;,
    // ...
  }
}
</code></pre>
<p>Create an <code>index.ts</code> with the following content to conveniently access the generated types and functions:</p>
<pre><code class="language-typescript">export * from &quot;./ApiClient&quot;;
export * from &quot;./Entities&quot;;
</code></pre>
<p>To get the files referenced here, make sure that the <code>frontendPath</code> you configured in the backend project's <code>build.gradle</code> points to the <code>src</code> directory of your NPM project and execute FeGen.</p>
<p>Configure the build script in your <code>package.json</code> and specify the correct <code>main</code> and <code>types</code> files:</p>
<pre><code class="language-json">{
  // ...
  &quot;main&quot;: &quot;./dist/index.js&quot;,
  &quot;types&quot;: &quot;./dist/index.d.ts&quot;,
  &quot;scripts&quot;: {
    &quot;build&quot;: &quot;npm run tsc&quot;,
    // ...
  },
  // ...
}
</code></pre>
<p>Now you can specify this project as a dependency for your frontends or publish it to a registry.</p>
<p>An example for an API project can be found in <code>fegen-examples/fegen-example-gradle/web-api</code> within FeGen's git repository.</p>
<h2 id="defining-the-api-object"><a class="header" href="#defining-the-api-object">Defining the api object</a></h2>
<p>No matter whether you use a separate API project or generate your code right into a subdirectory of your frontend project, there will be the following two files in the directory specified by <code>frontendPath</code>:</p>
<ul>
<li><code>Entities.ts</code> exports interfaces that correspond to entities and projections defined in the backend.</li>
<li><code>ApiClient.ts</code> exports the class <code>ApiClient</code> which contains a client object for each entity defined in the backend.</li>
</ul>
<p>To use the generated code, you must instantiate the generated <code>ApiClient</code> class first which takes an instance of the runtime's class <code>FetchAdapter</code>.</p>
<p>Its constructor takes an object that you can use to configure how the generated code accesses your backend.
The following optional properties will be evaluated by the generated code if they are present:</p>
<table><thead><tr><th>Property</th><th>Description</th><th>Default</th></tr></thead><tbody>
<tr><td><code>baseUrl</code></td><td>Under which URL your backend can be accessed. No matter if you specify the base URL, if you specified the property <code>spring.data.rest.base-path</code> in the <code>application.properties</code> of your spring application, it will be considered by the api client, so you must not repeat it in this property</td><td><code>&quot;&quot;</code>, so the protocol and host of the current site will be used (works only in browsers)</td></tr>
<tr><td><code>interceptors</code></td><td>see below</td><td><code>[]</code> (No interceptors)</td></tr>
<tr><td><code>fetchImpl</code></td><td>An implementation similar to <code>window.fetch</code> that the generated code will use for all its requests. This is needed for example if the code will not run in the browser, but in an environment, where the default <code>fetch</code> is not available. Take note that in order to use authentication, you might need an implementation of <code>fetch</code> that preserves cookies.</td><td><code>window.fetch</code> (works only in browsers)</td></tr>
</tbody></table>
<p>It might be a good idea to do instantiate the ApiClient in your frontend project once and export the <code>ApiClient</code> instance as a singleton.
For the remainder of this guide it is assumed that the variable <code>apiClient</code> contains such an instance.</p>
<pre><code class="language-typescript">import { ApiClient } from &quot;your-api-project&quot;;
import { FetchAdapter } from &quot;@materna-se/fegen-runtime&quot;;

export default new ApiClient(new FetchAdapter({
    baseUrl: &quot;https://example.com&quot;
}));
</code></pre>
<h2 id="intercepting-requests"><a class="header" href="#intercepting-requests">Intercepting requests</a></h2>
<p>Interceptors can be used to manipulate the requests that the generated code makes as well as the responses it gets.
They can be used e.g. to implement authentication, logging or retrying requests.
An interceptor is simply a function that takes a URL and request options as well as a function <code>executor</code> that accepts the previous two parameters, makes the actual request and returns a response wrapped into a promise.
The interceptor itself must also return a <code>Promise&lt;Response&gt;</code>.
The simplest interceptor looks like this:</p>
<pre><code class="language-typescript">const noopInterceptor = async (url: string, options: FetchOptions | undefined, executor: FetchFn): Promise&lt;FetchResponse&gt; =&gt; {
    return await executor(url, options);
}
</code></pre>
<p>While this interceptor is useless, as it does not do change anything if it is added, interceptors allow you to manipulate the request before sending it.
The following interceptor can be used for basic authentication:</p>
<pre><code class="language-typescript">const basicAuthInterceptor: Interceptor = (url, options, execution) =&gt; {
  const optionsWithAuth = {
      // Keep all options but the headers 
    ...options,
    headers: {
      // Keep all headers but replace Authorization
      ...options?.headers,
      Authorization: &quot;Basic &quot; + btoa(credentials.username + &quot;:&quot; + credentials.password)
    }
  }
  // Continue with the request, but with included Authorization header
  return execution(url, optionsWithAuth);
}
</code></pre>
<p>And this one will retry 2 times if a connection error occurred:</p>
<pre><code class="language-typescript">const retryInterceptor: Interceptor = async (url, options, execution) =&gt; {
  let tries = 0;
  while (true) {
    try {
      return await execution(url, options);
    } catch (ex) {
      if (tries &lt; 3) {
        // Probably just a bad connection, lets try again
        tries++;
        await new Promise(resolve =&gt; setTimeout(resolve, 1_000));
      } else {
        // It failed 3 times, lets give up
        throw ex;
      }
    }
  }
}
</code></pre>
<p>You can pass any number of interceptors to the <code>FetchAdapter</code> by specifying an array for the corresponding property.
Once the generated code wants to make a request, it will call the first interceptor in the array.
Whenever that interceptor calls the <code>executor</code> function, the second interceptor in the array will be called with the <code>url</code> and <code>options</code> passed to the <code>executor</code> by the first interceptor and the third interceptor as <code>executor</code> and so forth.
Whenever the last interceptor calls the <code>executor</code>, the actual request will be made with <code>window.fetch</code> or your <code>fetchFn</code> if you specified one.</p>
<h2 id="using-the-api"><a class="header" href="#using-the-api">Using the API</a></h2>
<p>Assume that you have defined an entity class with the name <code>User</code>. Then methods for basic CRUD operations will be contained in its client object <code>apiClient.userClient</code>.
The operation for reading all objects for an entity takes <code>page</code>, <code>size</code> and <code>sort</code> as parameters.
The latter determines the order of the returned objects.
The other parameters allow you to only query a certain page (starting with offset 0) assuming that the list of entities is divided in pages of size <code>size</code>.</p>
<p>The following code demonstrates the basic CRUD functionality offered by FeGen's generated clients:</p>
<pre><code class="language-typescript">// Create a user
const createdUser: User = await apiClient.userClient.create({
    firstName: &quot;First&quot;,
    lastName: &quot;Last&quot;
});

// Get all users
let users: User[] = (await apiClient.userClient.readAll()).items;
// Get 5 users
let pagedUsers: PagedItems&lt;User&gt; = (await apiClient.userClient.readAll(0, 5));
// If there are more than 5 users
if (pagedUsers.page.totalPages &gt; 0) {
    // Get the next 5 users
    users = (await apiClient.userClient.readAll(1, 5)).items;
}
// Get the first 20 users sorted by name
const sortedUsers: User[] = (await apiClient.userClient.readAll(0, 20, &quot;lastName,ASC&quot;));
// Get a single user object by its id
const user: User = await apiClient.userClient.readOne(idOfUser);

// Update a user
createdUser.firstName = &quot;Other First Name&quot;;
await apiClient.userClient.update(createdUser);

// Delete a user
await apiClient.userClient.delete(createdUser);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kotlin-1"><a class="header" href="#kotlin-1">Kotlin</a></h1>
<p>Besides Typescript, FeGen can also generate Kotlin code.
This enables you to use FeGen when calling your API from an Android app.
You can also use the generated code in another backend application such as another Spring Boot server.</p>
<h2 id="setup-1"><a class="header" href="#setup-1">Setup</a></h2>
<p>In both cases, you will need to add the FeGen Kotlin runtime to your <code>build.gradle</code> (or your <code>pom.xml</code>):</p>
<pre><code class="language-groovy">implementation &quot;com.github.materna-se.fegen:fegen-kotlin-runtime:1.0-RC9&quot;
</code></pre>
<p>Especially in the android case, you need to make sure that you are using at least Java 1.8 when building your app.
You can achieve this by adding the following to the <code>android</code> section of your <code>build.gradle</code>:</p>
<pre><code class="language-groovy">compileOptions {
    sourceCompatibility JavaVersion.VERSION_1_8
    targetCompatibility JavaVersion.VERSION_1_8
}
kotlinOptions { jvmTarget = &quot;1.8&quot; }
</code></pre>
<p>Analogous to Typescript, you might want to create a dedicated Gradle project that you generate your code into and that other Kotlin projects can depend on.</p>
<h2 id="using-the-generated-api"><a class="header" href="#using-the-generated-api">Using the generated API</a></h2>
<p>To use the generated code in a client project, you need to add the API project created in the last step as a dependency.</p>
<p>Before making the actual calls to your endpoints, you need to create an Instance of the generated <code>ApiClient</code> class.
You therefore also need to construct a <code>FetchAdapter</code> object which the generated code will use to get context information like the base url under which to find your endpoints, so you need to pass the latter as an argument:</p>
<pre><code class="language-kotlin">return ApiClient(FetchAdapter(&quot;http://localhost:8080/&quot;))
</code></pre>
<p>By default, the <code>FetchAdapter</code> will provide an <code>OkHttp</code> client to make requests to all code generated by FeGen.
However, you can pass your own client implementation to the constructor of <code>FetchAdapter</code>.
This can be useful to register interceptors to handle e.g. authentication.</p>
<p>In contrast to Typescript, FeGen generates two classes for each repository.</p>
<p>The classes ending in <code>Client</code> contain the actual code to contact your Spring application, but their methods may only be called from a <code>suspend</code>-function.
This allows you to use the asynchronous IO capabilities of Kotlin.</p>
<p>If you need to use the generated code from a normal function and have no problem with the thread blocking for as long as the request takes, you can instead use the methods of the <code>Repository</code> classes which wrap the methods of the <code>Client</code> to make the thread wait for the request, so they can be called anywhere.</p>
<p>The following example shows how you can use basic CRUD functionality generated by FeGen in Kotlin while assuming that the instance of <code>ApiClient</code> is bound to the <code>apiClient</code> variable:</p>
<pre><code class="language-kotlin">// Create a user
val createdUser = apiClient.userRepository.create(UserBase(
        firstName = &quot;First&quot;,
        lastName = &quot;Last&quot;)
)

// Get all users
val allUsers: List&lt;User&gt; = apiClient.userRepository.readAll().items
// Get 5 users
val pagedUsers: PagedItems&lt;User&gt; = apiClient.userRepository.readAll(0, 5)
// If there are more than 5 users
if (pagedUsers.page.totalPages &gt; 0) {
    // Get the next 5 users
    users = apiClient.userRepository.readAll(1, 5).items
}
// Get the first 20 users sorted by name
val sortedUsers: List&lt;User&gt; = apiClient.userRepository.readAll(0, 20, &quot;lastName,ASC&quot;)
// Get a single user object by its id
val user: User = apiClient.userRepository.readOne(idOfUser)

// Update a user
val changeRequest = createdUser.copy(firstName = &quot;Other First Name&quot;)
val changedUser = apiClient.userRepository.update(changeRequest)

// Delete a user
apiClient.userRepository.delete(changedUser)
</code></pre>
<p>If you want to use more advanced features like e.g. projections or relationships, refer to the page for that specific feature.
Although the examples will be in Typescript, the corresponding Kotlin code will be analogous.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="security"><a class="header" href="#security">Security</a></h1>
<p>With FeGen security, clients can determine their permissions to access entities, searches and custom endpoints at runtime.
This works by using two endpoints that supply meta information about authorization.
These endpoints are automatically added by adding the <code>fegen-spring-util</code> library in your application.</p>
<p>When you call these endpoints, you supply them with a path.
The endpoint then determines whether you are authorized to call that path.
This can be useful if you want to display a UI to the user and show or hide certain elements depending on the user's permissions to retrieve or change related data.</p>
<p>The permissions always apply to your current authentication when making the call.
It does not matter whether that happened using basic HTTP authentication, OIDC or any other method.
The endpoints ask Spring's <code>WebSecurityConfiguration</code> class, so all authorization methods configured using Spring will be considered.
If you do not have Spring security enabled, the endpoints will return that you are allowed to do everything.</p>
<p>FeGen generates methods that allow you to determine your permissions for specific entities as well as searches and custom endpoints.</p>
<h2 id="entities-1"><a class="header" href="#entities-1">Entities</a></h2>
<p>To determine what permissions you have on a certain entity, just call the <code>allowedMethods</code> method.
It will return an object with boolean fields that tell you whether you can create, read, update or delete that entity.</p>
<pre><code class="language-typescript">const mayCreateUser: boolean = await apiClient.userClient.allowedMethods().create;
</code></pre>
<h2 id="searches"><a class="header" href="#searches">Searches</a></h2>
<p>When FeGen generates a search method named <code>searchMethod</code>, another method named <code>isSearchMethodAllowed</code> is also generated.
It returns a boolean indicating whether you have the correct permissions to call the former method.</p>
<pre><code class="language-typescript">apiClient.userClient.isSearchFindByNamesAllowed()
</code></pre>
<h2 id="custom-endpoints-1"><a class="header" href="#custom-endpoints-1">Custom Endpoints</a></h2>
<p>This works the same as searches.
For each custom endpoint method <code>customEndpoint</code> that FeGen generates, it also generates another method named <code>isCustomEndpointAllowed</code>.</p>
<pre><code class="language-typescript">if (apiClient.someController.isMyEndpointAllowed()) {
    button.onclick = () =&gt; apiClient.someController.myEndpoint(&quot;someParameter&quot;);
} else {
    button.style = &quot;display: none&quot;;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pitfalls"><a class="header" href="#pitfalls">Pitfalls</a></h1>
<p>This document describes common pitfalls you might run into while using FeGen and how you can fix them.</p>
<h4 id="plugin-not-found"><a class="header" href="#plugin-not-found">Plugin not found</a></h4>
<blockquote>
<pre><code>&gt; Plugin with id 'de.materna.fegen.web' not found.
</code></pre>
</blockquote>
<p>Make sure you added a dependency to the correct fegen plugin.
Its name should end with <code>gradle-plugin</code> if you are using gradle or <code>maven-plugin</code> if you are using maven.</p>
<pre><code>// Wrong:
classpath &quot;com.github.materna-se.fegen:fegen-web:1.0&quot;
// Correct:
classpath &quot;com.github.materna-se.fegen:fegen-web-gradle-plugin:1.0&quot;
</code></pre>
<p>Also make sure you are using the <code>fegen-web-*-plugin</code> to generate Typescript and <code>fegen-kotlin-*-plugin</code> to generate Kotlin code.</p>
<h4 id="outdated-gradle-version"><a class="header" href="#outdated-gradle-version">Outdated gradle version</a></h4>
<blockquote>
<pre><code>&gt; Failed to notify project evaluation listener.
   &gt; org.gradle.api.tasks.TaskContainer.named(Ljava/lang/String;)Lorg/gradle/api/tasks/TaskProvider;
</code></pre>
</blockquote>
<p>Your gradle version is too old.
You can update your gradle wrapper using the following command.
The line <code>apply plugin: 'de.materna.fegen.web'</code> must be removed before doing so because Gradle will need to be able to read your <code>build.gradle</code> even for updating.</p>
<pre><code class="language-shell script">./gradlew wrapper --gradle-version 6.6.1
</code></pre>
<p>You might need to update your other plugins as well.
Otherwise, you might get an error message such as the following:</p>
<blockquote>
<pre><code>FAILURE: Build failed with an exception.

* Where:
Build file &lt;Line with &quot;apply plugin: 'kotlin'&quot;&gt;

* What went wrong:
A problem occurred evaluating project '&lt;Your project&gt;'.
&gt; java.lang.ExceptionInInitializerError (no error message)
</code></pre>
</blockquote>
<p>This happens if you are trying to use the Kotlin plugin with the version <code>1.2</code> with a recent Gradle version.
Use at least <code>1.3</code> to avoid this problem.</p>
<h4 id="nullable-fields"><a class="header" href="#nullable-fields">Nullable fields</a></h4>
<p>You may have encountered the following error message:</p>
<pre><code>Field &quot;xyz&quot; in entity &quot;com.example.entity.SomeEntity&quot; is implicitly nullable
    Please add a @Nullable annotation if this is intentional
    or add a @NotNull annotation to forbid null values
    Set implicitNullable to WARN to continue the build despite missing @Nullable annotations
</code></pre>
<p>Java does not distinguish between types that are nullable and types that are not.
The target languages of FeGen (Typescript and Kotlin) however use different types depending on whether <code>null</code> is an allowed value.</p>
<p>If nullability is not explicitly specified using an annotation for an entity's field, by default that field will be treated as nullable by Spring.
Therefore, FeGen will make the corresponding field in Typescript and Kotlin nullable.
This default behavior will cause the null safety features of those languages to become useless for the generated types and may encourage the bad practice of not handling the nullability of a field correctly.</p>
<p>The error message you saw is there to prevent this from happening.
Consider whether <code>null</code> is a meaningful value for this field and, if not, add a <code>@NotNull</code> annotation to the field.
Otherwise, if nullability is intentional, explicitly mark the field with <code>@Nullable</code>.</p>
<p>The default behaviour of FeGen is to fail the build with an error if it encounters a field that is implicitly nullable.
If you just want to display a warning, add the following to the <code>fegenWeb</code> or <code>fegenKotlin</code> section in your <code>build.gradle</code>:</p>
<pre><code>implicitNullable = DiagnosticsLevel.WARN
</code></pre>
<p>To completely ignore implicit nullability, change <code>WARN</code> to <code>ALLOW</code></p>
<h4 id="missing-cors-configuration"><a class="header" href="#missing-cors-configuration">Missing CORS configuration</a></h4>
<p>You may see the following error message in your browser when using the generated client:</p>
<blockquote>
<p>Cross-Origin Request Blocked</p>
</blockquote>
<p>Check the hostname accessed in the request.
If it is the one you would expect, it is probably a missing or wrong CORS configuration.
Take a look at <a href="reference/../quickstart/backend.html#cors">this step of the quick start guide</a> to add or fix it.</p>
<h4 id="client-accesses-wrong-host"><a class="header" href="#client-accesses-wrong-host">Client accesses wrong host</a></h4>
<p>If you are using the browser, you may see an error message like this:</p>
<blockquote>
<p>Cross-Origin Request Blocked</p>
</blockquote>
<p>In all cases, you may notice that a wrong host / domain is accessed when using the api client generated by FeGen.</p>
<p>The reason for this may be that you have not configured Spring to correctly determine under which URL it can be reached.
That may be necessary if you are using a reverse proxy or development server.
The Spring server must know how it can be reached, because when it returns an entity, it also includes links to manipulate this entity and related entities in its response and FeGen relies on those links to be correct.
Some proxies will however not include the original host name in the HTTP request, but instead place it in a header like <code>X-Forwarded-Host</code>.</p>
<p><strong>Trusting those headers may however impose a security risk</strong>, as they can be added by malicious clients if do not implement measures to prevent that (See <a href="https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/spring-framework-reference/web.html#filters-forwarded-headers">this</a> section of the Spring documentation).
You can tell spring to trust those headers by adding the following to your <code>application.properties</code>.</p>
<pre><code class="language-properties">server.forward-headers-strategy=framework
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="developing-fegen"><a class="header" href="#developing-fegen">Developing FeGen</a></h1>
<p>This chapter explains how you can get started with adding features or fixing bugs in FeGen.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building"><a class="header" href="#building">Building</a></h1>
<p>To build your own version of FeGen, clone this repository if you haven't already using the following command:</p>
<pre><code class="language-shell script">git clone --recurse-submodules https://github.com/materna-se/fegen.git
</code></pre>
<p>If you have not used the <code>--recurse-submodules</code>, execute the following in the cloned directory:</p>
<pre><code class="language-shell script">git submodule init
git submodule update
</code></pre>
<p>Tests are included in the <code>fegen-examples</code> directory and can be run by executing the following commands:</p>
<pre><code>cd fegen-examples
./gradlew build
</code></pre>
<p>The <code>fegen-examples</code> directory consists of a gradle project that contains the line <code>includeBuild '..'</code> in its <code>settings.gradle</code>.
This causes it to use gradle's composite build feature and ensures that the example and tests inside it always use the FeGen instance built from the sources in the directory where this <code>README.MD</code> resides.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture-1"><a class="header" href="#architecture-1">Architecture</a></h1>
<p>Once you have successfully built FeGen and ran the tests, you can focus on making the changes you have in mind.
This page gives an overview over the directory structure of the FeGen repository.</p>
<h2 id="project-structure"><a class="header" href="#project-structure">Project structure</a></h2>
<p>The actual code within the FeGen repository is structured in three ways.</p>
<p>First, the examples and tests are contained inside the <code>fegen-examples</code> git submodule, while the actual implementation resides in the <code>fegen-core</code>, <code>fegen-kotlin</code> and <code>fegen-web</code> directories.</p>
<p>Second, FeGen is divided by the target language (the language that client code should be generated in).
Target specific code can be found in <code>fegen-kotlin</code> and <code>fegen-web</code> (Typescript), while code that is agnostic of the target language, like the analysis of the Spring application, is contained in <code>fegen-core</code>.</p>
<p>Third, FeGen is divided by whether code is specific to Maven or Gradle or whether it belongs to a runtime.
For example, in <code>fegen-core</code>, <code>fegen-gradle</code> and <code>fegen-maven</code> contain code specific to the Maven and Gradle plugins while <code>fegen-spring-util</code> is the library that will be included in the Spring application at runtime.
Most code, however is executed when building a project that uses FeGen and is not specific to Maven or Gradle.
That code lies in a <code>src</code> directory just inside <code>fegen-core</code>.</p>
<h2 id="fegen-examples"><a class="header" href="#fegen-examples">/fegen-examples</a></h2>
<p>The example repository that is included as a git submodule here also contains the tests for FeGen.
By using an <code>includeBuild</code> statement in the <code>settings.gradle</code>, the examples and tests are always run with the current FeGen code in the repository.
The maven example only illustrates how FeGen can be included in a Maven project.
Since FeGen behaves the same no matter if it is included using Gradle or Maven, the tests and the usage examples are inside the <code>fegen-example-gradle</code> directory.</p>
<h2 id="book"><a class="header" href="#book">/book</a></h2>
<p>This directory contains the sources for the site you are looking at right now.
The sources consist of markdown files that are rendered into this structured HTML book format using <code>mdbook</code>.
When you are adding or modifying features, you should adapt the book.</p>
<p>To do that, first go to the <a href="https://github.com/rust-lang/mdBook">mdbook repository</a> to download the latest <code>mdbook</code> binary for your OS to the <code>/book</code> directory and execute it:</p>
<pre><code class="language-shell">./mdbook serve
</code></pre>
<p>This will start a development server so you get a live preview of your changes.
Once you are done, call <code>./mdbook build</code>.</p>
<h2 id="docs"><a class="header" href="#docs">/docs</a></h2>
<p>This is the directory where <code>mdbook</code> will output the HTML for the book.
As an output directory, this would usually be on the <code>.gitignore</code> list, but it needs to be included in the git, so it can be served with GitHub pages.
Do not make any manual changes to this directory, but call <code>./mdbook build</code> in the <code>/book</code> directory to generate the contents.</p>
<h2 id="buildsrc"><a class="header" href="#buildsrc">/buildSrc</a></h2>
<p>This directory contains the license header plugin that is used by Gradle to check that each file in the repository has the correct license header set.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-a-custom-build-locally"><a class="header" href="#using-a-custom-build-locally">Using a Custom Build Locally</a></h1>
<p>If you want to use a custom build of FeGen in your project, you can install all FeGen plugins to your local <code>.m2</code> directory by running the following command in the root project:</p>
<pre><code class="language-shell">./gradlew publishToMavenLocal
</code></pre>
<p>To include the built plugins in a gradle project, insert <code>mavenLocal()</code> as a repository for your dependencies as well as your buildscript in your <code>build.gradle</code>.
If you are using a Kotlin client, you also need to add <code>mavenLocal()</code> in the <code>repositories</code> section of your client's <code>build.gradle</code>.
If you are generating Typescript code, you need to specify the relative path to the <code>fegen-web/fegen-web-runtime</code> directory within the FeGen repository in the client's <code>package.json</code>:</p>
<pre><code class="language-json">{
  &quot;dependencies&quot;: {
    &quot;@materna-se/fegen-runtime&quot;: &quot;../../fegen/fegen-web/fegen-web-runtime&quot;
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing"><a class="header" href="#contributing">Contributing</a></h1>
<p>If you have fixed a bug or added a feature, you are welcome to contribute it back to the main FeGen repository.
There is no CI/CD pipeline yet, but still make sure your pull request fulfills the following criteria:</p>
<ul>
<li>Your commit of <code>fegen</code> references the correct commit of <code>fegen-examples</code> in the <code>fegen-examples</code> git subproject</li>
<li>Running <code>./gradlew build</code> is successful in the <code>fegen</code> repository's root directory as well as in the <code>fegen-examples</code> git subproject</li>
<li>If you added a feature
<ul>
<li>you have added some tests to make sure it is working and won't be accidentally broken in the future</li>
<li>you have added some documentation in the book and ran <code>mdbook build</code></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="publishing"><a class="header" href="#publishing">Publishing</a></h1>
<p>This guide describes the process of publishing all JVM artefacts on Maven Central as well as publishing the web runtime on <code>npmjs.org</code>.</p>
<h2 id="one-time-preparation"><a class="header" href="#one-time-preparation">One-time preparation</a></h2>
<p>First you will need an account on <a href="https://www.npmjs.com">npmjs.com</a> and need to join the <code>materna-se</code> organization.
Then you execute <code>npm login</code> and enter your credentials in the prompt.</p>
<p>You will also need a <a href="https://issues.sonatype.org/secure/Signup!default.jspa">Sonatype Jira Account</a> to be able to publish to Maven Central.
It will have to be activated for the groupId <code>com.github.materna-se</code> as seen in the following ticket: <a href="https://issues.sonatype.org/browse/OSSRH-55108">https://issues.sonatype.org/browse/OSSRH-55108</a>.
Talk to Jonas Tamimi for details.</p>
<p>While you are waiting for the activation, you can generate a personalized GPG key.
To do that, follow steps 8-10 of the &quot;Prerequisite Steps&quot; of this guide: <a href="https://dzone.com/articles/publish-your-artifacts-to-maven-central">https://dzone.com/articles/publish-your-artifacts-to-maven-central</a>.
Make sure to remember the Key ID from the line <code>key 27835B3BD2A2061F marked as ultimately trusted</code>.</p>
<p>Afterwards, perform step 7 of the &quot;Publishing Steps&quot; where you upload your public key to a key server.</p>
<p>To make sure that the FeGen gradle project finds your key, you need to have the following lines in the file <code>.gradle/gradle.properties</code> within your home directory:</p>
<pre><code class="language-properties">mavenCentral.username=your_sonatype_org_username
mavenCentral.password=your_sonatype_org_password
signing.keyId=02468ACE
signing.secretKeyRingFile=/home/clemens/.gradle/secring.gpg
</code></pre>
<p>The last value points to a file within a directory, where you will have to execute the following command to save your GPG key:</p>
<pre><code class="language-shell">gpg --export-secret-keys -o secring.gpg
</code></pre>
<p>The second to last value must be the ID of the key you generated earlier.</p>
<h2 id="publishing-1"><a class="header" href="#publishing-1">Publishing</a></h2>
<ol>
<li><strong>Increment all Versions</strong><br />
First you will need to increment the version of all maven artifacts and, if applicable, of the web runtime.
The first ones reside in the top level <code>build.gradle</code> file. I strongly recommend setting all versions here on the same value and thereby accepting also publishing artifacts without changes.
The version of the web runtime can be adjusted in the file <code>fegen-web/fegen-web-runtime/package.json</code>.
It is important to also adapt all references to FeGen versions. They can be located in the various <code>build.gradle</code> files as well as in the documentation within the <code>book</code> directory.
You can use the global (project wide) search to look for the old versions.
Afterwards, you will need to rebuild the book (Execute <code>./mdbook build</code> in <code>/book</code>, see <a href="developing/./architecture.html#book">Architecture</a>).
When you are done, commit your changes.</li>
<li><strong>Execute Maven Publish</strong><br />
Execute <code>./gradlew publish</code> in your root directory. A dialog will pop up where you will need to enter the password for your GPG key.</li>
<li><strong>Confirm Upload to Maven Central</strong><br />
The uploaded files of the <code>publish</code> task will end up <a href="https://oss.sonatype.org/#welcome">here</a>.
Log in using the button in the top right and click on <code>Staging Repositories</code> on the left.
Your upload should be in the list, and you can check whether all files have been successfully uploaded.
Then you can select each uploaded artifact and click <code>Close</code> and <code>Release</code> on the toolbar.</li>
<li><strong>Publishing the Web Runtime</strong><br />
Execute <code>npm publish</code> in <code>fegen-web/fegen-web-runtime</code>.</li>
<li><strong>Merging into the main branch</strong><br />
The <code>master</code> branch should always represent the current state.
That is why you should merge the <code>develop</code> branch into it using <code>--no-ff</code>.</li>
<li><strong>Tagging</strong><br />
Tag the commit created by the merge with the version number of the Maven artifacts and the version of the web runtime.</li>
<li><strong>Switch back to develop</strong><br />
To prevent accidentally committing on the <code>master</code> branch, it is best to immediately switch back to <code>develop</code>.</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
