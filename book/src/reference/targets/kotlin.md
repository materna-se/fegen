# Kotlin

There are two reasons you might be interested in generating Kotlin code.

You can either create a gradle project that depends on the inter-service runtime.
This enables you to call the API that the code was generated for from another Spring application.

The other option is to create an Android library to use the Spring API in an Android application.

## Inter service

To make your Spring API available to other Spring applications, create a gradle project to contain the generated code and add the following dependencies to your `build.gradle`:

- `com.github.materna-se.fegen:fegen-kotlin-interservice-runtime:1.0-RC9`
- `org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.3`
- `com.fasterxml.jackson.module:jackson-module-kotlin:2.10.1`

## Android

To use generated code when developing Android apps, create a library project in Android Studio and copy the contents of `fegen-kotlin/fegen-kotlin-android-runtime` to the source directory into the package `de.materna.fegen.adapter.android`.

## Using the generated API

To use the generated code in a client project, you need to add the API project created in the last step as a dependency.

Before making the actual calls to your endpoints, you need to create an Instance of the generated `ApiClient` class.
You therefore also need to construct a `FetchAdapter` object which the generated code will use to get context information like the base url under which to find your endpoints, so you need to pass the latter as an argument:

```kotlin
return ApiClient(FetchAdapter("http://localhost:8080/"))
```

By default, the `FetchAdapter` will provide an `OkHttp` client to make requests to all code generated by FeGen.
However, you can pass your own client implementation to the constructor of `FetchAdapter`.
This can be useful to register interceptors to handle e.g. authentication.

In contrast to Typescript, FeGen generates two classes for each repository.

The classes ending in `Client` contain the actual code to contact your Spring application, but their methods may only be called from a `suspend`-function.
This allows you to use the asynchronous IO capabilities of Kotlin.

If you need to use the generated code from a normal function and have no problem with the thread blocking for as long as the request takes, you can instead use the methods of the `Repository` classes which wrap the methods of the `Client` to make the thread wait for the request, so they can be called anywhere.

The following example shows how you can use basic CRUD functionality generated by FeGen in Kotlin while assuming that the instance of `ApiClient` is bound to the `apiClient` variable:

```kotlin
// Create a user
val createdUser = apiClient.userRepository.create(UserBase(
        firstName = "First",
        lastName = "Last")
)

// Get all users
val allUsers: List<User> = apiClient.userRepository.readAll().items
// Get 5 users
val pagedUsers: PagedItems<User> = apiClient.userRepository.readAll(0, 5)
// If there are more than 5 users
if (pagedUsers.page.totalPages > 0) {
    // Get the next 5 users
    users = apiClient.userRepository.readAll(1, 5).items
}
// Get the first 20 users sorted by name
val sortedUsers: List<User> = apiClient.userRepository.readAll(0, 20, "lastName,ASC")
// Get a single user object by its id
val user: User = apiClient.userRepository.readOne(idOfUser)

// Update a user
val changeRequest = createdUser.copy(firstName = "Other First Name")
val changedUser = apiClient.userRepository.update(changeRequest)

// Delete a user
apiClient.userRepository.delete(changedUser)
```

If you want to use more advanced features like e.g. projections or relationships, refer to the page for that specific feature.
Although the examples will be in Typescript, the corresponding Kotlin code will be analogous.
