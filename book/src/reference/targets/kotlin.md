# Kotlin

Besides Typescript, FeGen can also generate Kotlin code.
This enables you to use FeGen when calling your API from an Android app.
You can also use the generated code in another backend application such as another Spring Boot server.

## Setup

In both cases, you will need to add the FeGen Kotlin runtime to your `build.gradle` (or your `pom.xml`):

```groovy
implementation "com.github.materna-se.fegen:fegen-kotlin-runtime:1.0-RC9"
```

Especially in the android case, you need to make sure that you are using at least Java 1.8 when building your app.
You can achieve this by adding the following to the `android` section of your `build.gradle`:

```groovy
compileOptions {
    sourceCompatibility JavaVersion.VERSION_1_8
    targetCompatibility JavaVersion.VERSION_1_8
}
kotlinOptions { jvmTarget = "1.8" }
```

Analogous to Typescript, you might want to create a dedicated Gradle project that you generate your code into and that other Kotlin projects can depend on.

## Using the generated API

To use the generated code in a client project, you need to add the API project created in the last step as a dependency.

Before making the actual calls to your endpoints, you need to create an Instance of the generated `ApiClient` class.
You therefore also need to construct a `FetchAdapter` object which the generated code will use to get context information like the base url under which to find your endpoints, so you need to pass the latter as an argument:

```kotlin
return ApiClient(FetchAdapter("http://localhost:8080/"))
```

By default, the `FetchAdapter` will provide an `OkHttp` client to make requests to all code generated by FeGen.
However, you can pass your own client implementation to the constructor of `FetchAdapter`.
This can be useful to register interceptors to handle e.g. authentication.

In contrast to Typescript, FeGen generates two classes for each repository.

The classes ending in `Client` contain the actual code to contact your Spring application, but their methods may only be called from a `suspend`-function.
This allows you to use the asynchronous IO capabilities of Kotlin.

If you need to use the generated code from a normal function and have no problem with the thread blocking for as long as the request takes, you can instead use the methods of the `Repository` classes which wrap the methods of the `Client` to make the thread wait for the request, so they can be called anywhere.

The following example shows how you can use basic CRUD functionality generated by FeGen in Kotlin while assuming that the instance of `ApiClient` is bound to the `apiClient` variable:

```kotlin
// Create a user
val createdUser = apiClient.userRepository.create(UserBase(
        firstName = "First",
        lastName = "Last")
)

// Get all users
val allUsers: List<User> = apiClient.userRepository.readAll().items
// Get 5 users
val pagedUsers: PagedItems<User> = apiClient.userRepository.readAll(0, 5)
// If there are more than 5 users
if (pagedUsers.page.totalPages > 0) {
    // Get the next 5 users
    users = apiClient.userRepository.readAll(1, 5).items
}
// Get the first 20 users sorted by name
val sortedUsers: List<User> = apiClient.userRepository.readAll(0, 20, "lastName,ASC")
// Get a single user object by its id
val user: User = apiClient.userRepository.readOne(idOfUser)

// Update a user
val changeRequest = createdUser.copy(firstName = "Other First Name")
val changedUser = apiClient.userRepository.update(changeRequest)

// Delete a user
apiClient.userRepository.delete(changedUser)
```

If you want to use more advanced features like e.g. projections or relationships, refer to the page for that specific feature.
Although the examples will be in Typescript, the corresponding Kotlin code will be analogous.
