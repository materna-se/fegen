# ðŸ§¹ FeGen for Spring Boot

FeGen generates frontend code based on your Spring backend so you can consume your Spring Data REST API in a type safe manner.
Typescript and Kotlin are supported as frontend languages, so you can use FeGen when creating a web app, a native Android app or another Spring application.

An example project demonstrating the usage of FeGen can be found in the git submodule `fegen-examples`.
Run the following command to check it out if you did not clone this repository using `git clone --recurse-submodules`:

```shell script
git submodule init
git submodule update
```

## Features

FeGen plugins are available for Gradle as well as Maven.
Code generated by FeGen enables you to access the following Spring features:

- Call CRUD operations on `@RepositoryRestResource`s while using pagination and sorting
- Fetch multiple related entities in one API call using projections
- Use repository- as well as custom searches
- Call custom endpoints

Code can be generated for the following target platforms:

- Typescript (To be used in e.g. a React app)
- Kotlin
    - Inter service (To be used in another Spring application)
    - Android

## Limitations / Roadmap

FeGen currently has some limitations such as the following which may be lifted in future versions:

- Embeddables can be used, but they may only contain primitive types since references to other entities are not yet supported
- A plugin for Swift (to use in iOS apps) exists, but is not yet publicly released
- Generating code for API endpoints used to up- or download files is not supported
- There are some tests for the generated code, however, currently no CI/CD pipeline exists

## Guide

The following guide describes how to use FeGen with a main project that contains a Spring backend sub project.
FeGen will generate code for two different sub projects that enable type safe usage of the API in Typescript and Kotlin respectively.
The backend implementation will be in Kotlin in the examples, however using Java is also supported by FeGen.

If you run into any issue while using FeGen, check if it is listed in the [common pitfalls](./PITFALLS.MD) document. 

### Preparing the Backend

The first step to use FeGen is to include the FeGen plugins for either Typescript, Kotlin or both in your build file.
If you are using gradle, you need to add a dependency in the `buildscript` within your `build.gradle`.
Make sure you have `mavenCentral()` set as one of your `buildscript` repositories.
You will need gradle version `6.0.1` or later for the plugin to work. 

```
buildscript {
    repositories {
        ...
        mavenCentral()
    }
    dependencies {
        ...
        classpath "com.github.materna-se.fegen:fegen-web-gradle-plugin:1.0-RC7" // For Typescript
        classpath "com.github.materna-se.fegen:fegen-kotlin-gradle-plugin:1.0-RC7" // For Kotlin
    }
}
```

Then you need to apply the plugins to your project.

```
apply plugin: 'de.materna.fegen.web'
apply plugin: 'de.materna.fegen.kotlin'
```

Applying the plugin enables you to configure the fegen plugins using the `fegenWeb` and `fegenKotlin` sections.

```
fegenWeb {
    scanPkg = "com.example.your.main.package"
    entityPkg = "com.example.your.main.package.entity"
    repositoryPkg = "com.example.your.main.package.repository"
    frontendPath = "../web-api/src"
}

fegenKotlin {
    scanPkg = "com.example.your.main.package"
    frontendPath = "../kotlin-api/src/main/kotlin"
    frontendPkg = "com.example.your.main.package.api"
}
```

If you want to use custom endpoints and are using a Spring version that ships with version 1.0.0 or later of `spring-hateoas`, you will need also need to add `fegen-spring-util` as a dependency.
This ensures that links required by FeGen will be added to the return values of custom endpoints.

```
dependencies {
    ...
    implementation "com.github.materna-se.fegen:fegen-spring-util:1.0-RC7"
}
```

If you are using maven, add a configuration like the following to the `build/plugins` section of your `pom.xml`:

```
<plugin>
    <groupId>com.github.materna-se.fegen</groupId>
    <artifactId>fegen-web-maven-plugin</artifactId>
    <version>1.0-RC7</version>
    <configuration>
        <scanPkg>com.example.your.main.package</scanPkg>
        <entityPkg>com.example.your.main.package.entity</entityPkg>
        <repositoryPkg>com.example.your.main.package.repository</repositoryPkg>
        <frontendPath>../web-api/src</frontendPath>
    </configuration>
</plugin>
```

To use custom endpoints with `spring-hateoas >= 1.0`, you should also add the following to the `dependencies` section.

```
<dependency>
    <groupId>com.github.materna-se.fegen</groupId>
    <artifactId>fegen-spring-util</artifactId>
    <version>1.0-RC7</version>
</dependency>
```

#### Configuration

The following configuration keys are mandatory:

| Key | Description |
| --- | --- |
| `scanPkg` | The package that contains all entities, projections, repositories and custom endpoints you want to generate frontend code for |
| `frontendPath` | The directory to which the generated (Typescript or Kotlin) files should be written. It must exist and should be specified relative to the `targetProject`. If you are generating Kotlin code, specify the source directory corresponding to the root package. It might be useful to create a sub project for each target language containing solely the generated code in case multiple applications should communicate with the backend. |

The following configuration keys are optional:

| Key | Default value | Description |
| --- | --- | --- |
| `targetProject` | The project the fegen plugin is applied to | The project that contains the spring application for which frontend code should be generated |
| `entityPkg` | `${scanPkg}.entity` | The package that contains all entities and projections you want to generate frontend code for |
| `repositoryPkg` | `${scanPkg}.repository` | The package that contains all repositories and custom endpoints you want to generate frontend code for |
| `datesAsString` | `false` | Whether time data such as `java.time.LocalDateTime` should be transmitted as strings |
| `implicitNullable` | `"ERROR"` | How to treat fields of entities that are nullable, but not explicitly annotated with `@Nullable`. Possible values are `"ERROR"`, `"WARN"` and `"ALLOW"` |

The following configuration keys are required when the output of FeGen is Kotlin code (meaning that the fegenKotlin plugin is used):

| Key | Description |
| --- | --- |
| `frontendPkg` | The package to which the frontend code should be generated |

<!-- TODO: How to configure maven projects -->

#### Development Server

If you use a development server provided by your frontend framework (such as React) it is convenient to enable the proxying of requests that the frontend cannot handle to your backend server.
In React this can be done by adding the following property to your `package.json`.

```
"proxy": "http://localhost:8080"
```

However, if you use this setup, you might run into two issues.

The first one arises from conflicts of endpoints that you use in your frontend as well as your backend.
For example, a GET request to `/users` may cause your frontend server to return an HTML page with a list of users, while your backend might return a JSON list of available users.
To avoid problems associated with URL clashes like that, you can specify a base path for your backend.

```
spring.data.rest.base-path=api
```

The second issue will occur because spring will include URIs to objects in its responses to REST requests.
The code generated by FeGen will try to use those links to access the corresponding objects.

The default behaviour of Spring is to use absolute URIs that point to the address and port that Spring has opened.
This presents a problem when the frontend is delivered from the frontend development server (e.g. at `http://localhost:3000`) and FeGen tries to make a request to the backend server (e.g. at `http://localhost:8080`) using one of the included links from a former request.
Modern browsers will block such a cross origin request for security reasons.

The best way to solve this is to add the following line to your `application.properties`.

```
server.forward-headers-strategy=framework
```

This will cause Spring to use the HTTP headers added by the frontend development server to the requests it proxies to determine the correct location and port for links inside its responses.

Another way to solve this is to make the backend server include the `Access-Control-Allow-Origin` header to allow the frontend server to access it.
This may however introduce a security risk.

## Creating the API projects

Before you can run the FeGen tasks in gradle, you should create an API project for each target language you want to generate code for.
Although FeGen allows you directly generate code into your frontend projects, creating separate projects for the generated code allows you to share it between multiple frontends.

### Typescript

For Typescript as target language, you should create an NPM project having a dependency on Typescript and one on the FeGen runtime.
The latter contains code that is used by the source files generated by FeGen.

 ```shell script
npm init
npm install --save-dev typescript
npm install @materna-se/fegen-runtime
```

Make sure that the `frontendPath` you configured in the backend project's `build.gradle` points to the `src` directory of your NPM project.

An example for an API project can be found in `fegen-examples/fegen-example-gradle/web-api`.

### Kotlin

There are two options when generating Kotlin code.
You can either create a gradle project that depends on the inter service runtime.
This enables you to call the API that the code was generated for from another Spring application.
The other option is to create an Android library to use the Spring API in an Android application.

#### Inter service

To make your Spring API available to other Spring applications, create a gradle project to contain the generated code and add the following dependencies to your `build.gradle`:

- `com.github.materna-se.fegen:fegen-kotlin-interservice-runtime:1.0-RC7`
- `org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.3`
- `com.fasterxml.jackson.module:jackson-module-kotlin:2.10.1`

#### Android

To use generated code when developing Android apps, create a library project in Android Studio and copy the contents of `fegen-kotlin/fegen-kotlin-android-runtime` to the source directory into the package `de.materna.fegen.adapter.android`.

## Using the generated API

To use the generated code in a client project, you need to add the API project created in the last step as a dependency.
The examples use Typescript as frontend language, but the generated Kotlin code can be used in a similar way.

### Basic Usage

This section describes how to make basic REST requests using FeGen.

#### Backend

First you need to create classes for the entities you want to access using REST.
If you are using Kotlin in the backend, those classes may look like the following.

```kotlin
@Entity
class User {
    
    @Id @GeneratedValue var id: Long = -1

    @NotNull lateinit var firstName: String
    
    @NotNull lateinit var lastName: String

    @Projection(name = "baseProjection", types = [User::class])
    interface BaseProjection {
        val id: Long
        val firstName: String
        val lastName: String
    }
}
```

Make sure the following rules apply to your entities in order for them to work with FeGen.
Take note that in Java you will need getters and setters for each field.

- They are located in the package specified by `entityPkg`
- They have an `@Entity` annotation
- They have an `id` field of type `Long`
    - That field is annotated with `@Id` and `@GeneratedValue`
    - That field is initialized with `-1`
- Every other field is annotated with `@NotNull` or `@Nullable` (even in Kotlin)
- They have a base projection

The last one is important since there are certain scenarios in which entities returned by the backend will not have certain properties that are required by the code generated by FeGen.

A projection is an interface that satisfies the following criteria.

- It is located in the package specified by `entityPkg`
- It is annotated with `@Projection`
    - The `types` property of the annotation contains the class of the entity for which the interface is a projection
- It contains a getter for a subset of the fields declared in the entity (In Kotlin, a `val` field is sufficient)
    - If the type an entity field is another entity, the type of the getter in the projection must be a projection of the other entity

For a projection to be the base projection of an entity, it needs to fulfill the following additional rules.

- The `name` property of its `@Projection` annotation must be `"baseProjection"`
- It must include a getter (or a val in Kotlin) for the `id` field of the entity

The last step to create a REST resource that can be used with FeGen is to create a repository for your entity class.
It should be an interface meeting the following requirements.

- It is located in the package specified by `repositoryPkg`
- It is annotated with `@RepositoryRestResource`
- It extends `JpaRepository` with your entity and `Long` as type parameters

```kotlin
@RepositoryRestResource
interface UserRepository: JpaRepository<User, Long> {}
```

Each time you modify your backend code you can run FeGen to update the generated frontend code from your backend gradle project directory.

```shell script
gradle fegenWeb fegenKotlin
```

#### Frontend

After running the code generation, there should be two files in the directory specified by `frontendPath`.

`Entities.ts` exports interfaces that correspond to entities and projections defined in the backend.
`ApiClient.ts` exports the class `ApiClient` which contains a client object for each entity defined in the backend.

If you specified the property `spring.data.rest.base-path` in the `application.properties` of your spring appplication, you need to include that path in the `baseUrl` parameter when instantiating the `ApiClient`.
For the web target, protocol and domain may be omitted in `baseUrl`.
In this case, the website's domain will be used.
It might be a good idea to do instantiate the ApiClient in your frontend project once and export the `ApiClient` instance as a singleton.
For the remainder of this guide it is assumed that the variable `apiClient` contains such an instance.

```typescript
import {ApiClient} from "your-api-project";

export default new ApiClient(undefined, "api");
```

Assume that you have defined an entity class with the name `User`. Then methods for basic CRUD operations will be contained in its client object `apiClient.userClient`.
The operation for reading all objects for an entity takes `page`, `size` and `sort` as parameters.
 The latter determines the order of the returned objects.
 The other parameters allow you to only query a certain page (starting with offset 0) assuming that the list of entities is divided in pages of size `size`.
 
```typescript
// Create a user
const createdUser: User = await apiClient.userClient.create({
    firstName: "First",
    lastName: "Last"
});

// Get all users
let users: User[] = (await apiClient.userClient.readAll()).items;
// Get 5 users
let pagedUsers: PagedItems<User> = (await apiClient.userClient.readAll(0, 5));
// If there are more than 5 users
if (pagedUsers.page.totalPages > 0) {
    // Get the next 5 users
    users = (await apiClient.userClient.readAll(1, 5)).items;
}
// Get the first 20 users sorted by name
const sortedUsers: User[] = (await apiClient.readAll(0, 20, "name,ASC"));
// Get a single user object by its id
const user: User = await apiClient.userClient.readOne(idOfUser);

// Update a user
createdUser.firstName = "Other First Name";
await apiClient.userClient.update(createdUser);

// Delete a user
await apiClient.userClient.delete(createdUser);
```

### Relationships

You can declare relationships between entities in the backend using the `@OneToOne`, `@OneToMany`, `@ManyToOne` or `@ManyToMany` annotations on fields whose types are entities. 
In the frontend there are two ways to access values related to a given entity object.

#### Including Related Values in the Backend

You can use projections to include fields that contain related entities.
Assume you have a `User` entity that has a field `address` annotated with `@OneToOne` containing an `Address` entity.
You can then create the following projection.

```kotlin
@Projection(name = "withAddress", types = [User::class])
interface UserWithAddress {
    val id: Long
    // ... other fields like first and last name
    val address: Address.BaseProjection
}
```

It is important to not include entity classes in projections as field types, but other projections.
Otherwise, issues can arise in the frontend that are caused by link properties missing from certain objects returned by the REST API.

In the frontend, methods corresponding to your projection will be generated in the entity's client that allow you to retrieve all or a single object based on your entity with the fields specified in your projection.
FeGen will also generate an interface for all projections you specify.

```typescript
const users: UserWithAddress[] = (await apiClient.userClient.readProjectionsUserWithAddress()).items;
```

#### Reading Related Values in the Frontend

There are cases in which it is not advisable to use projections to access related data.
For example, in an app to schedule meetings, you might want to display a list of all `Room` entities, but without loading all its associated `Meeting` entities that resemble the meetings scheduled in that room.
However, once the user clicks on a room, you want to display the meetings for that specific room.

This could be done with the `readMeetings` method in the `RoomClient` that accepts a `Room` object and returns all `Meeting`s associated with that room.
Such a method is generated for each field of an entity with a relationship annotation.

```typescript
const rooms: Room[] = (await apiClient.roomClient.readAll()).items;
const roomSelectedByUser = rooms[27];
const meetings: Meeting[] = await apiClient.readMeetings(roomSelectedByUser);
``` 

#### Modifying Relationships in the backend

You can use the following methods to add or remove relationships between entities.
It is important that all the objects passed to such a set method have already been created in the backend.
Conversely, the `meetingToDelete` object will not be deleted from the database.

```typescript
apiClient.roomClient.setMeetings(room, meetings);
apiClient.roomClient.deleteFromMeetings(room, meetingToDelete);
```

If your relationship is `@OneToMany` or `@ManyToMany`, you can use the following method to add a single object to the relationship without removing the others.

```typescript
apiClient.roomClient.addToMeetings(room, meetingToAdd);
```

### Repository Searches

Spring enables you to create endpoints for custom searches by specifying methods in a repository interface.
They can either have a query annotation specifying their return value or have their semantics implied by their name.

```kotlin
@Query("SELECT u FROM User u WHERE u.firstName LIKE CONCAT('%', :name, '%') OR u.lastName LIKE CONCAT('%', :name, '%')")
fun findByNameContaining(
        @RequestParam @Param("name") name: String,
        pageable: Pageable
): Page<Contact>
```

To use such a search method in your frontend, it has to satisfy certain criteria:

- It must be defined in a repository meeting the criteria specified in the Basic Usage section
- Its name must start with `find`
- It must *not* have a `@RestResource` annotation where `exported` is set to `false`

Your repository search may either return an entity, a `List` of entities, or a `Page` of entities.
The latter will enable you to retrieve only a subset of the returned entities by specifying a page and a page size in the frontend.
You will need to add a `Pageable` parameter to your method for this to work.

In your frontend code, a corresponding method will be generated in the client that corresponds to the repository that contains the search method.

```typescript
apiClient.userClient.searchFindByNameContaining("name_part");
```

### Custom Searches

Custom searches are similar to repository searches, but reside in their own controller.
Instead of specifying queries, your are able to write Java or Kotlin code to calculate their response.

You first need to create a controller class that will contain your search methods.
There are no restrictions on how many of those controllers may exist.

```kotlin
@BasePathAwareController
@RequestMapping(path = ["/search"])
class SearchController {
    // ...
}
```

The controller class must meet the following requirements in order for FeGen to detect it:

- It has a `@BasePathAwareController` annotation
- It has a `@RequestMapping` annotation whose value or `path` ends with `/search`

Then you can then add search methods to your controller:

```kotlin
@RequestMapping("usersByRegex")
fun usersByRegex(
    @RequestParam(name = "nameRegex") name: String
): ResponseEntity<CollectionModel<EntityModel<User.BaseProjection>>> {
    // ...
    return ResponseEntity.ok(CollectionModel.wrap(userList))
}
```

Those methods must adhere to the following rules to work with FeGen:

- They have a `@RequestMapping` annotation
- Their parameters must have a `@RequestParam` annotation
- They have a return type of the form `ResponseEntity<CollectionModel<EntityModel<P>>>` where `P` is a projection

Using a custom search in typescript works the same as with repository searches.

### Custom Endpoints

Custom endpoints are similar to custom searches, but can modify the database when called.
They can be specified as methods inside a controller class.

```kotlin
@RestController
@RequestMapping("/api/users")
open class CustomEndpointController {

    // ...
}
```

For a controller to be recognized as a container for custom endpoints, it needs to fulfill the following criteria:

- It must have a `@RestController` annotation
- It must have a `@RequestMapping` annotation whose value or `path` that ends with the same segment as an entity's REST endpoint. (For a `User` entity it should end with `/users` and for an `Address` entity it should end with `/addresses`)

Take note that the `spring.data.rest.base-path` you specified in `application.properties` will not be applied to the `@RequestMapping`.

You can then specify custom endpoints in such classes where parameters are annotated with `@RequestParam`, `@PathVariable` or `@RequestBody`. 

```kotlin
@RequestMapping("createOrUpdate", method = [RequestMethod.POST])
open fun createOrUpdateContact(
        @RequestParam firstName: String,
        @RequestParam lastName: String
): ResponseEntity<EntityModel<User>> {
    // ...
}
```

FeGen will generate a Typescript method in the API client corresponding to the class' `@RequestMapping` `path` or value if the Java or Kotlin method has a `@RequestMapping` (or `@GetMapping`, `@PostMapping`, etc.) annotation.

Custom endpoints must have a void return type or return entities. 
In the latter case, the entity class must be wrapped in an `EntityModel` (if a single entity should be returned) or in `CollectionModel` or `PagedModel` (if multiple entities should be returned).
Those classes themselves must be wrapped in a `ResponseEntity`.

Custom endpoints can also return pojos. In this case, a pojo or a list of those must be wrapped in a `ResponseEntity`.

To reliably use the returned values in the frontend, make sure you added the `fegen-spring-util` dependency to your Spring project.

Calling a custom endpoint in the frontend works the same as with repository searches.

## Building FeGen

If you want to use a custom build, you can install all FeGen plugins to your local `.m2` directory by running the following command in the root project:

```
gradle publishToMavenLocal
```

To include the built plugins in a gradle project, insert `mavenLocal()` as a repository in the buildscript in `build.gradle`.

Tests are included in the `fegen-examples` directory and can be run by executing the following commands:

```
cd fegen-examples
gradle build
``` 

The `fegen-examples` directory consists of a gradle project that contains the line `includeBuild '..'` in its `settings.gradle`.
This causes it to use gradle's composite build feature and ensures that the example and tests inside it always use the FeGen instance built from the sources in the directory where this `README.MD` resides.

The source code of FeGen is split into two gradle sub projects that correspond to the frontend languages that code can be generated for.
Additionally, `fegen-core` contains the code that is independent of the target language.
Each of these directories contain two sub projects that contain code that is specific to maven and gradle respectively.
